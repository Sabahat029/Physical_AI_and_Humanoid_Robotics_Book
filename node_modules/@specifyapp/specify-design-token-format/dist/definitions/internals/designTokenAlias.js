import { z } from 'zod';
import { TreePath } from '../../engine/state/path/TreePath.js';
/* ------------------------------------------
   $alias string value
--------------------------------------------- */
export const specifyAliasStringValueSchema = z
    .string()
    .min(1)
    .refine(value => {
    // a regex to match a "." separated string where no part is empty
    const regex = /^((?!\.)(?!.*\.\.)(?!.*\.$)[^.]+\.)*((?!\.)(?!.*\.\.)(?!.*\.$)[^.]+)$/;
    return regex.test(value);
});
/* ------------------------------------------
   Top level alias
--------------------------------------------- */
export const specifyTopLevelAliasSignatureSchema = z
    .object({
    $alias: specifyAliasStringValueSchema,
})
    .strict();
export function matchIsTopLevelAliasSignature(value) {
    if (value !== null &&
        !Array.isArray(value) &&
        typeof value === 'object' &&
        '$alias' in value &&
        !('$mode' in value)) {
        return (specifyAliasStringValueSchema.safeParse(value.$alias).success ?? false);
    }
    return false;
}
/* ------------------------------------------
   Mode and Value level alias
--------------------------------------------- */
export const specifyModeAndValueLevelAliasSignatureSchema = z
    .object({
    $alias: specifyAliasStringValueSchema,
    $mode: z.string(),
})
    .strict();
export function matchIsModeAndValueLevelAliasSignature(value) {
    if (value !== null &&
        !Array.isArray(value) &&
        typeof value === 'object' &&
        '$alias' in value &&
        '$mode' in value &&
        typeof value.$mode === 'string') {
        return (specifyAliasStringValueSchema.safeParse(value.$alias).success ?? false);
    }
    return false;
}
export function matchIsDesignTokenAliasSignature(value) {
    if (value !== null && !Array.isArray(value) && typeof value === 'object' && '$alias' in value) {
        return (specifyAliasStringValueSchema.safeParse(value.$alias).success ?? false);
    }
    return false;
}
export function stripDesignTokenAliasValue(rawAlias) {
    const alias = rawAlias.$alias;
    let isTopLevelAlias = false;
    let mode;
    if (matchIsModeAndValueLevelAliasSignature(rawAlias)) {
        mode = rawAlias.$mode;
    }
    else {
        isTopLevelAlias = true;
    }
    const splitAlias = TreePath.fromString(alias);
    return {
        isTopLevelAlias,
        alias,
        mode,
        currentPath: splitAlias,
        designTokenName: splitAlias.tail(),
    };
}
