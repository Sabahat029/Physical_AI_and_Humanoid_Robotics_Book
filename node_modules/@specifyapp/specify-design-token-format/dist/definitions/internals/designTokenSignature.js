import { z } from 'zod';
import { specifyTopLevelAliasSignatureSchema, } from './designTokenAlias.js';
import { treeNodeCommonPropertiesSchema } from './designTokenTree.js';
import { specifyDesignTokenValueModeSchema } from './designTokenMode.js';
export function matchIsDesignTokenSignature(maybeToken) {
    if (typeof maybeToken === 'object' &&
        maybeToken !== null &&
        !Array.isArray(maybeToken) &&
        '$value' in maybeToken &&
        maybeToken.$value !== undefined) {
        return true;
    }
    return false;
}
export function makeSpecifyDesignTokenSchema(typeName, valueSchema, withAliases) {
    return z
        .object({
        $type: z.literal(typeName),
        $value: withAliases
            ? z.union([
                specifyTopLevelAliasSignatureSchema,
                z.record(specifyDesignTokenValueModeSchema, valueSchema),
            ])
            : z.record(specifyDesignTokenValueModeSchema, valueSchema),
    })
        .merge(treeNodeCommonPropertiesSchema)
        .strict();
}
export const specifyGenericDesignTokenSignatureSchema = z
    .object({
    $type: z.string({
        invalid_type_error: 'Expected a string for $type',
        required_error: 'Expected a string for $type',
    }),
    $value: z.unknown({
        required_error: 'Expected a defined value for $value',
    }),
})
    .merge(treeNodeCommonPropertiesSchema)
    .strict();
/**
 * @deprecated - Not flexible enough, use `specifyGenericDesignTokenSignatureSchema` instead
 */
export function validateSpecifyGenericDesignTokenSignature(value) {
    return specifyGenericDesignTokenSignatureSchema.parse(value);
}
