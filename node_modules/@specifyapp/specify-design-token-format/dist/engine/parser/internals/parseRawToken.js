import { getDesignTokenDefinition, treeNodeNameSchema, validateSpecifyDesignTokenTypeName, } from '../../../definitions/index.js';
import { specifyGenericDesignTokenSignatureSchema } from '../../../definitions/internals/designTokenSignature.js';
import { parseRawTokenValue } from './parseRawTokenValue.js';
export function parseRawToken(path, rawToken) {
    const { $type: typeCandidate, $value: valueCandidate, $description, $extensions, } = specifyGenericDesignTokenSignatureSchema.parse(rawToken, { path: path.toArray() });
    const extractedName = path.tail();
    const name = treeNodeNameSchema.parse(extractedName, { path: path.toArray() });
    const $type = validateSpecifyDesignTokenTypeName(typeCandidate);
    const definition = getDesignTokenDefinition($type);
    const { $value } = definition.aliasableTokenZodSchema
        .pick({ $value: true })
        .parse({ $value: valueCandidate });
    const { aliasParts, primitiveParts } = parseRawTokenValue($value, path);
    let isTopLevelAlias = false;
    if (aliasParts.length === 1 && aliasParts[0].type === 'topLevelAlias') {
        isTopLevelAlias = true;
    }
    let modes = null;
    if (!isTopLevelAlias) {
        // Compute local modes
        const modesSet = [...aliasParts, ...primitiveParts].reduce((acc, part) => {
            if (part.type !== 'topLevelAlias') {
                acc.add(part.localMode);
            }
            return acc;
        }, new Set());
        modes = Array.from(modesSet);
    }
    return {
        path,
        name,
        $type,
        $value,
        $description,
        $extensions,
        definition,
        isTopLevelAlias,
        modes,
        analyzedValueAliasParts: aliasParts,
        analyzedValuePrimitiveParts: primitiveParts,
    };
}
