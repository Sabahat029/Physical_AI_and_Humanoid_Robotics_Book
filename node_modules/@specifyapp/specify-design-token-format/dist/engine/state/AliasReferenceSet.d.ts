import { ValuePath } from './path/ValuePath.js';
import { TokenState } from './TokenState.js';
import { UnresolvableTokenState } from './UnresolvableTokenState.js';
import { TreePath } from './path/TreePath.js';
type AliasReferenceBase = {
    from: {
        treePath: TreePath;
        valuePath: ValuePath;
        mode: string | null;
    };
    to: {
        treePath: TreePath;
        mode: string | null;
    };
};
export type ResolvableAliasReference = AliasReferenceBase & {
    isResolvable: true;
};
export type UnresolvableAliasReference = AliasReferenceBase & {
    isResolvable: false;
    reason: string;
};
export type AliasReference = ResolvableAliasReference | UnresolvableAliasReference;
export type ResolvedStatefulAliasReference = AliasReferenceBase & {
    status: 'resolved';
    tokenState: TokenState;
};
export type UnresolvableStatefulAliasReference = AliasReferenceBase & {
    status: 'unresolvable';
    unresolvableTokenState: UnresolvableTokenState;
};
export type StatefulAliasReference = ResolvedStatefulAliasReference | UnresolvableStatefulAliasReference;
export declare class AliasReferenceSet {
    #private;
    [Symbol.iterator](): Generator<AliasReference, void, unknown>;
    /**
     * @internal
     * @param treePath
     */
    getDeepFromTreePath(treePath: TreePath): Array<AliasReference>;
    /**
     * Take a starting alias and will dig until the end
     * To retrieve the target value
     */
    getOneDeepFrom(from: {
        treePath: AliasReference['from']['treePath'];
        valuePath: AliasReference['from']['valuePath'];
        mode: AliasReference['from']['mode'];
    }): AliasReference | undefined;
    /**
     * @internal
     * @param treePath
     */
    getDeepToTreePath(treePath: TreePath): Array<AliasReference>;
    private checkCircularDependencies;
    add(reference: AliasReference): void;
    updateAtFrom(at: AliasReference['from'], candidate: AliasReference): void;
    upsertAtFrom(reference: AliasReference): void;
    deleteOne({ treePath, valuePath, mode }: AliasReference['from']): void;
    deleteManyFrom(from: {
        treePath: AliasReference['from']['treePath'];
        mode?: AliasReference['from']['mode'];
        valuePath?: AliasReference['from']['valuePath'];
    }): void;
    unlinkManyTo(to: {
        treePath: AliasReference['to']['treePath'];
        mode?: AliasReference['to']['mode'];
    }, reason?: string): void;
    linkManyTo(to: {
        treePath: AliasReference['to']['treePath'];
        mode?: AliasReference['to']['mode'];
    }): void;
    hasFrom(from: AliasReference['from']): boolean;
    getOne(from: AliasReference['from']): AliasReference | undefined;
    getManyTo<O extends {
        isResolvable?: boolean;
    }, R extends O extends {
        isResolvable: true;
    } ? Array<ResolvableAliasReference> : O extends {
        isResolvable: false;
    } ? Array<UnresolvableAliasReference> : Array<AliasReference>>(to: {
        treePath: AliasReference['to']['treePath'];
        mode?: AliasReference['to']['mode'];
    }, options?: O): R;
    getManyFrom<O extends {
        isResolvable?: boolean;
    }, R extends O extends {
        isResolvable: true;
    } ? Array<ResolvableAliasReference> : O extends {
        isResolvable: false;
    } ? Array<UnresolvableAliasReference> : Array<AliasReference>>(from: {
        treePath: AliasReference['from']['treePath'];
        valuePath?: AliasReference['from']['valuePath'];
        mode?: AliasReference['from']['mode'];
    }, options?: O): R;
    /**
     * Retrieve the AliasReference of the exact value, or the one of a parent,
     * e.g, the mode level alias, or a property inside a composite token
     */
    getOneOrParentFrom({ treePath, valuePath, mode, }: {
        treePath: AliasReference['from']['treePath'];
        valuePath: AliasReference['from']['valuePath'];
        mode: AliasReference['from']['mode'];
    }): AliasReference | undefined;
    /**
     * Retrieve the target coordinates from a starting point.
     * E.g, if you want the value of a dimension, it'll tell you where is the JSON value.
     * It'll be either on a number token, or the value of a dimension token.
     */
    getOneDeepAndPathInfosFrom({ treePath: initialTreePath, valuePath, mode: targetMode, }: {
        treePath: AliasReference['from']['treePath'];
        valuePath: AliasReference['from']['valuePath'];
        mode: AliasReference['from']['mode'];
    }): {
        aliasRef: {
            from: {
                mode: string | null;
                valuePath: ValuePath;
                treePath: TreePath;
            };
            to: {
                treePath: TreePath;
                mode: string | null;
            };
            isResolvable: true;
        } | {
            from: {
                mode: string | null;
                valuePath: ValuePath;
                treePath: TreePath;
            };
            to: {
                treePath: TreePath;
                mode: string | null;
            };
            isResolvable: false;
            reason: string;
        };
        toValuePath: ValuePath;
        traversedPath: ValuePath;
    } | undefined;
    clear(): void;
}
export {};
