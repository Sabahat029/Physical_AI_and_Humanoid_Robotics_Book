import { deepSetJSONValue } from '../../utils/deepSetJSONValue.js';
import { deepClone } from '../utils/deepClone.js';
export class TokenRawValueParts {
    #rawParts = [];
    #unsafeAdd(part) {
        this.#rawParts.push(part);
    }
    *[Symbol.iterator]() {
        const data = this.#rawParts;
        for (let i = 0; i < data.length; i++) {
            yield data[i];
        }
    }
    get size() {
        return this.#rawParts.length;
    }
    get modes() {
        return Array.from(new Set(this.#rawParts.map(part => part.mode)));
    }
    clear() {
        this.#rawParts.length = 0;
    }
    /*
     * By returning `true` you want to delete the value, and `false` keep it.
     */
    filterDelete(fn) {
        this.#rawParts = this.#rawParts.filter(v => !fn(v));
    }
    has({ mode, valuePath }) {
        return this.#rawParts.some(part => {
            return part.mode === mode && part.valuePath.toString() === valuePath.toString();
        });
    }
    hasChildren({ mode, valuePath }) {
        return this.#rawParts.some(part => part.mode === mode &&
            valuePath.length < part.valuePath.length &&
            part.valuePath.toString().includes(valuePath.toString()));
    }
    hasParent({ mode, valuePath }) {
        // You don't have a parent if the value path length is 1
        if (valuePath.length <= 1) {
            return false;
        }
        const path = valuePath.clone();
        while (path.length > 0) {
            if (this.#rawParts.some(part => part.mode === mode && part.valuePath.toString().includes(path.toString())))
                return true;
            path.pop();
        }
        return false;
    }
    /**
     * This function will retrieve the nearest parent
     */
    getParent({ mode, valuePath }) {
        // If the value path length is 1 you can't have a parent
        if (valuePath.length <= 1) {
            return undefined;
        }
        const path = valuePath.clone();
        path.pop();
        while (path.length > 0) {
            const valuePart = this.#rawParts.find(part => part.mode === mode && part.valuePath.toString() === path.toString());
            if (valuePart)
                return valuePart;
            path.pop();
        }
        return undefined;
    }
    getRawPart({ mode, valuePath }) {
        return this.#rawParts.find(part => part.mode === mode && part.valuePath.toString() === valuePath.toString());
    }
    getRawPartsFromPrefix({ mode, prefixPath, }) {
        const output = this.#rawParts.filter(part => part.mode === mode && prefixPath.isRootOf(part.valuePath));
        return output.length === 0 ? undefined : output;
    }
    getChildren({ mode, valuePath }) {
        return this.#rawParts.filter(part => part.mode === mode &&
            valuePath.length < part.valuePath.length &&
            part.valuePath.toArray().includes(valuePath.toString()));
    }
    getAll({ mode } = {}) {
        if (mode) {
            return this.#rawParts.filter(part => part.mode === mode);
        }
        return [...this.#rawParts];
    }
    add(part) {
        if (this.has(part)) {
            return false;
        }
        this.#unsafeAdd(part);
        return true;
    }
    update(where, candidate) {
        const index = this.#rawParts.findIndex(part => part.mode === where.mode && part.valuePath.toString() === where.valuePath.toString());
        if (index === -1) {
            return false;
        }
        this.#rawParts[index] = candidate;
        return true;
    }
    upsert(where, candidate) {
        if (!this.update(where, candidate)) {
            this.add(candidate);
        }
    }
    delete(where) {
        const index = this.#rawParts.findIndex(part => part.mode === where.mode && part.valuePath.toString() === where.valuePath.toString());
        if (index === -1) {
            return false;
        }
        this.#rawParts.splice(index, 1);
        return true;
    }
    hasMode(mode) {
        return this.#rawParts.some(part => part.mode === mode);
    }
    renameMode(previousMode, nextMode) {
        let hasFound = false;
        this.#rawParts.forEach(part => {
            if (part.mode === previousMode) {
                part.mode = nextMode;
                hasFound = true;
            }
        });
        return hasFound;
    }
    deleteMode(mode) {
        const partsToDelete = this.#rawParts.filter(part => part.mode === mode);
        if (partsToDelete.length === 0) {
            return false;
        }
        partsToDelete.forEach(part => {
            const index = this.#rawParts.indexOf(part);
            /* v8 ignore next 3 */
            if (index === -1) {
                throw new Error('Cannot find index of RawValuePart');
            }
            this.#rawParts.splice(index, 1);
        });
        return true;
    }
    toObject() {
        const acc = {};
        this.#rawParts.forEach(part => {
            deepSetJSONValue(acc, [part.mode, ...part.valuePath.toArray()], part.value);
        });
        return acc;
    }
    toAnalyzedValuePrimitiveParts() {
        return this.#rawParts.map(part => ({
            type: 'primitive',
            localMode: part.mode,
            valuePath: part.valuePath.clone(),
            value: deepClone(part.value),
        }));
    }
}
