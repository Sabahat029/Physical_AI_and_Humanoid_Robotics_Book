import { treeNodeNameSchema } from '../../definitions/index.js';
import { validateTreeNodeDescription, validateTreeNodeExtensions, } from '../../definitions/internals/designTokenTree.js';
import { SDTFError } from '../../errors/index.js';
export class TreeNodeState {
    treeState;
    #name;
    #path;
    #description;
    #extensions;
    constructor(treeState, params) {
        this.treeState = treeState;
        this.#name = params.name;
        this.#path = params.path.clone(); // clone the array to the Node instance
        this.#description = params.$description;
        if (params.$extensions) {
            this.#extensions = JSON.parse(JSON.stringify(params.$extensions));
        }
    }
    get name() {
        return this.#name;
    }
    get path() {
        return this.#path;
    }
    /**
     * @deprecated Use `path.toString()` instead.
     */
    get stringPath() {
        return this.#path.toString();
    }
    get description() {
        return this.#description;
    }
    get extensions() {
        return this.#extensions;
    }
    get parentPath() {
        return this.#path.makeParentPath();
    }
    get parentStringPath() {
        return this.parentPath.toString();
    }
    rename(newName) {
        const validatedNewName = treeNodeNameSchema.parse(newName, {
            path: this.#path.toArray(),
        });
        const newPath = this.#path.makeParentPath().append(validatedNewName);
        if (validatedNewName === this.#name) {
            return false;
        }
        if (!this.treeState.isAvailablePath(newPath)) {
            throw new SDTFError('SDTF_PATH_ALREADY_TAKEN', `Path "${newPath}" is already taken.`);
        }
        this.#name = validatedNewName;
        this.#path = newPath;
        return true;
    }
    setPath(newPath) {
        if (!this.treeState.isAvailablePath(newPath)) {
            throw new SDTFError('SDTF_PATH_ALREADY_TAKEN', `Path "${newPath}" is already taken.`);
        }
        const extractedName = newPath.tail();
        const validatedNewName = treeNodeNameSchema.parse(extractedName, {
            path: this.#path.toArray(),
        });
        const validatedPath = newPath.makeParentPath().append(validatedNewName);
        this.#path = validatedPath;
        this.#name = validatedNewName;
    }
    updatePathItem(atIndex, replacer) {
        // We do not allow to update the last item of the path -> rename
        if (atIndex === this.#path.length - 1) {
            throw new SDTFError('SDTF_UPDATE_PATH', `Cannot update the last index of the path.`);
        }
        this.#path.replaceAt(atIndex, replacer);
    }
    updateDescription(description) {
        const validatedDescription = validateTreeNodeDescription(description);
        this.#description = validatedDescription;
    }
    updateExtensions(extensions) {
        const validatedExtensions = validateTreeNodeExtensions(extensions);
        this.#extensions = validatedExtensions;
    }
    getAllChildren() {
        return this.treeState.getChildrenOf(this.path);
    }
    getParent() {
        return this.treeState.getParentsOf(this.path, 1)[0];
    }
    /**
     * @internal
     */
    getCommonJSON() {
        return {
            ...(this.#description ? { $description: this.#description } : {}),
            ...(this.#extensions ? { $extensions: this.#extensions } : {}),
        };
    }
}
