import { JSONValue } from '../../utils/JSONDefinitions.js';
import { AnalyzedTokenValuePrimitivePart } from '../parser/internals/AnalyzedTokenValuePart.js';
import { ValuePath } from './path/ValuePath.js';
type ValuePart = {
    mode: string;
    valuePath: ValuePath;
    value: JSONValue;
};
type ValuePartSelector = {
    mode: ValuePart['mode'];
    valuePath: ValuePart['valuePath'];
};
export declare class TokenRawValueParts<Value = unknown> {
    #private;
    [Symbol.iterator](): Generator<ValuePart, void, unknown>;
    get size(): number;
    get modes(): string[];
    clear(): void;
    filterDelete(fn: (part: ValuePart) => boolean): void;
    has({ mode, valuePath }: ValuePartSelector): boolean;
    hasChildren({ mode, valuePath }: ValuePartSelector): boolean;
    hasParent({ mode, valuePath }: ValuePartSelector): boolean;
    /**
     * This function will retrieve the nearest parent
     */
    getParent({ mode, valuePath }: ValuePartSelector): ValuePart | undefined;
    getRawPart({ mode, valuePath }: ValuePartSelector): ValuePart | undefined;
    getRawPartsFromPrefix({ mode, prefixPath, }: {
        mode: string;
        prefixPath: ValuePath;
    }): [ValuePart, ...ValuePart[]] | undefined;
    getChildren({ mode, valuePath }: ValuePartSelector): ValuePart[];
    getAll({ mode }?: {
        mode?: string;
    }): ValuePart[];
    add(part: ValuePart): boolean;
    update(where: ValuePartSelector, candidate: ValuePart): boolean;
    upsert(where: ValuePartSelector, candidate: ValuePart): void;
    delete(where: ValuePartSelector): boolean;
    hasMode(mode: string): boolean;
    renameMode(previousMode: string, nextMode: string): boolean;
    deleteMode(mode: string): boolean;
    toObject(): Record<string, Value>;
    toAnalyzedValuePrimitiveParts(): Array<AnalyzedTokenValuePrimitivePart>;
}
export {};
