import { TreeNodeInterface, TreeNodeState } from './TreeNodeState.js';
import { DesignTokenDefinition } from '../../definitions/internals/createDesignTokenDefinition.js';
import { PickSpecifyDesignToken, SpecifyDesignTokenTypeName } from '../../definitions/index.js';
import { TreeState } from './TreeState.js';
import { TreeNodeExtensions } from '../../definitions/internals/designTokenTree.js';
import { RawValueSignature, StatefulValueResult } from './statefulValue/StatefulValueResult.js';
import { UnresolvableModeLevelAlias } from './statefulValue/aliasing.js';
import { UIValueResultSignature } from './statefulValue/UIValueResult.js';
import { AnalyzedSDTFNode } from '../parser/internals/AnalyzedSDTFNode.js';
import { AnalyzedToken } from '../parser/internals/parseRawToken.js';
import { AnalyzedTokenValuePrimitivePart } from '../parser/internals/AnalyzedTokenValuePart.js';
import { TreePath } from './path/TreePath.js';
export type ResolvedDeepStatefulValueForMode<Type extends SpecifyDesignTokenTypeName = SpecifyDesignTokenTypeName> = {
    tokenState: TokenState<Type>;
    targetMode: string;
    value: UnresolvableModeLevelAlias | RawValueSignature<Type>;
};
export type UpdateOptions = {
    overrideAliases?: boolean;
    allowModeCreation?: boolean;
};
export declare const defaultGetJSONTokenValueOptions: {
    readonly resolveAliases: true;
    readonly allowUnresolvable: true;
    readonly targetMode: null;
};
export type GetJSONTokenValueOptions<ResolveAliases extends boolean = boolean, AllowUnresolvable extends boolean = boolean, TargetMode extends string | null = null> = ResolveAliases extends true ? {
    resolveAliases: true;
    allowUnresolvable?: AllowUnresolvable;
    targetMode?: TargetMode;
} : {
    resolveAliases: false;
};
export declare function mergeGetJSONTokenValueOptions<ResolveAliases extends boolean, AllowUnresolvable extends boolean, TargetMode extends string | null>(candidate?: GetJSONTokenValueOptions<ResolveAliases, AllowUnresolvable, TargetMode>): Required<{
    resolveAliases: true;
    allowUnresolvable?: AllowUnresolvable | undefined;
    targetMode?: TargetMode | undefined;
}>;
export type TokenStateParams<Type extends SpecifyDesignTokenTypeName = SpecifyDesignTokenTypeName> = AnalyzedSDTFNode & {
    $type: Type;
    $description: string | undefined;
    $extensions: TreeNodeExtensions | undefined;
    definition: DesignTokenDefinition<string>;
    isTopLevelAlias: boolean;
    analyzedValuePrimitiveParts: Array<AnalyzedTokenValuePrimitivePart>;
    isFullyResolvable: boolean;
    modesResolvabilityMap: Map<string, boolean>;
};
export declare class TokenState<Type extends SpecifyDesignTokenTypeName = SpecifyDesignTokenTypeName, Value extends unknown = unknown, Mode extends string = string> extends TreeNodeState implements TreeNodeInterface {
    #private;
    readonly isToken = true;
    readonly isGroup = false;
    readonly isCollection = false;
    constructor(treeState: TreeState, { path, name, $description, $extensions, $type, definition, isTopLevelAlias, analyzedValuePrimitiveParts, isFullyResolvable, modesResolvabilityMap, }: TokenStateParams<Type>);
    get aliases(): import("./AliasReferenceSet.js").StatefulAliasReference[];
    /**
     * Validate the all the values and aliases are correct.
     * If not, it'll throw an error
     */
    validateValue(): void;
    /**
     * Get the Token type
     * @public
     */
    get type(): Type;
    /**
     * Get the SDTF JSON representation of the Token value
     * @public
     */
    get value(): PickSpecifyDesignToken<Type>['$value'];
    /**
     * Get the Token resolved modes
     * @public
     */
    get modes(): string[];
    /**
     * Get the Token resolved modes
     * @deprecated Use `this.modes` instead.
     */
    getModes(): string[];
    /**
     * Indicates whether the Token is a top level alias
     */
    get isTopLevelAlias(): boolean;
    /**
     * Indicates whether the Token holds unresolvable aliases
     */
    get isFullyResolvable(): boolean;
    /**
     * Get a map representation of whether the token holds unresolvable aliases per mode
     */
    get modesResolvability(): Record<string, boolean>;
    /**
     * Get the design token definition - containing validation schemas of the token
     */
    get definition(): DesignTokenDefinition<Type>;
    /**
     * Get the parent collection of the token if any
     */
    getCollection(): import("./CollectionState.js").CollectionState | undefined;
    /**
     * get a StatefulValueResult instance allowing to map over the token possible values for modes and aliases.
     */
    getStatefulValueResult(): StatefulValueResult<Type>;
    /**
     * Resolve the stateful value for a given mode
     * @param mode
     */
    resolveDeepStatefulValueForMode<T extends SpecifyDesignTokenTypeName = Type>(mode: string): ResolvedDeepStatefulValueForMode<T>;
    /**
     * Get the Stateful Value representation for frontend usage
     * @param targetMode
     */
    getUIValueResultOnMode(targetMode: string): UIValueResultSignature<Type>;
    /**
     * Rename the token
     * @param newName
     */
    rename(newName: string): boolean;
    /**
     * Rename a mode of the token
     * @param fromMode
     * @param toMode
     */
    renameMode(fromMode: string, toMode: string): void;
    /**
     * Update the whole value of the token (including modes)
     * @param nextValue
     */
    updateValue(nextValue: Partial<PickSpecifyDesignToken<Type, string, false, true>['$value']>, { allowModeCreation, overrideAliases }?: UpdateOptions): void;
    updateModeValue(mode: string, nextValue: Partial<PickSpecifyDesignToken<Type, string, true, false>['$value']>, { overrideAliases, allowModeCreation }?: UpdateOptions): void;
    /**
     * Resolve the aliases from the token
     */
    resolveValueAliases(): void;
    /**
     * Create a new mode for the token
     * @param mode
     * @param nextValue
     */
    createModeValue(mode: string, nextValue: PickSpecifyDesignToken<Type, string, true, false>['$value']): void;
    /**
     * Delete a mode of the token
     * @param mode
     */
    deleteModeValue(mode: string): void;
    /**
     * Get the JSON representation of the Token value
     * @param options - resolveAliases, allowUnresolvable, targetMode allows for more control over the returned value
     */
    getJSONValue<ResolveAliases extends boolean, AllowUnresolvable extends boolean = true, TargetMode extends Mode | null = null>(options?: GetJSONTokenValueOptions<ResolveAliases, AllowUnresolvable, TargetMode>): PickSpecifyDesignToken<Type, Mode, AllowUnresolvable extends true ? true : false, TargetMode extends string ? false : true>['$value'];
    /**
     * Get the JSON representation of the Token
     * @param options - resolveAliases, allowUnresolvable, targetMode allows for more control over the returned value
     */
    getJSONToken<ResolveAliases extends boolean, AllowUnresolvable extends boolean = true, TargetMode extends Mode | null = null>(options?: GetJSONTokenValueOptions<ResolveAliases, AllowUnresolvable, TargetMode>): PickSpecifyDesignToken<Type, Mode, AllowUnresolvable extends true ? true : false, TargetMode extends string ? false : true>;
    /**
     * Get serializable JSON representation of the Token
     * @internal
     */
    getJSONProperties(): PickSpecifyDesignToken<Type, Mode, true, true>;
    /**
     * Get serializable JSON representation of the Token
     * @internal
     */
    toJSON(): PickSpecifyDesignToken<Type, Mode, true, true>;
    /**
     * Moves the item to the specified path.
     *
     * @param {Array<string>} toPath - The path to move the item to.
     */
    move(toPath: TreePath): void;
    matchByType<Return>(matcher: {
        [K in SpecifyDesignTokenTypeName]?: (token: TokenState<K, Value, Mode>) => Return;
    }, missingFn: (token: TokenState) => Return): Return;
    matchJSONValueByType<MatchReturn, MissingReturn = undefined>(matcher: {
        [K in Type]?: (token: PickSpecifyDesignToken<K, string, false, false>['$value'], mode: string) => MatchReturn;
    }, missingFn: (token: TokenState) => MissingReturn): {
        [mode: string]: MatchReturn;
    } | MissingReturn | undefined;
    toTokenStateParams(): TokenStateParams;
    toAnalyzedToken(): AnalyzedToken;
    isString(): this is TokenState<'string'>;
    isNumber(): this is TokenState<'number'>;
    isBoolean(): this is TokenState<'boolean'>;
    isNull(): this is TokenState<'null'>;
    isArray(): this is TokenState<'array'>;
    isObject(): this is TokenState<'object'>;
    isIntegerNumber(): this is TokenState<'integerNumber'>;
    isZeroToOneNumber(): this is TokenState<'zeroToOneNumber'>;
    isArcDegreeNumber(): this is TokenState<'arcDegreeNumber'>;
    isRgbColorNumber(): this is TokenState<'rgbColorNumber'>;
    isPositiveNumber(): this is TokenState<'positiveNumber'>;
    isPositiveIntegerNumber(): this is TokenState<'positiveIntegerNumber'>;
    isPercentageNumber(): this is TokenState<'percentageNumber'>;
    isHexadecimalColorString(): this is TokenState<'hexadecimalColorString'>;
    isBitmap(): this is TokenState<'bitmap'>;
    isBitmapFormat(): this is TokenState<'bitmapFormat'>;
    isBlur(): this is TokenState<'blur'>;
    isBorder(): this is TokenState<'border'>;
    isBorderStyle(): this is TokenState<'borderStyle'>;
    isBorderStyleLineCap(): this is TokenState<'borderStyleLineCap'>;
    isBreakpoint(): this is TokenState<'breakpoint'>;
    isColor(): this is TokenState<'color'>;
    isCubicBezier(): this is TokenState<'cubicBezier'>;
    isDimension(): this is TokenState<'dimension'>;
    isDimensionUnit(): this is TokenState<'dimensionUnit'>;
    isDuration(): this is TokenState<'duration'>;
    isDurationUnit(): this is TokenState<'durationUnit'>;
    isFont(): this is TokenState<'font'>;
    isFontFamily(): this is TokenState<'fontFamily'>;
    isFontFeature(): this is TokenState<'fontFeature'>;
    isFontFeatures(): this is TokenState<'fontFeatures'>;
    isFontFormat(): this is TokenState<'fontFormat'>;
    isFontStyle(): this is TokenState<'fontStyle'>;
    isFontWeight(): this is TokenState<'fontWeight'>;
    isGradient(): this is TokenState<'gradient'>;
    isGradients(): this is TokenState<'gradients'>;
    isOpacity(): this is TokenState<'opacity'>;
    isRadius(): this is TokenState<'radius'>;
    isRadii(): this is TokenState<'radii'>;
    isShadow(): this is TokenState<'shadow'>;
    isShadows(): this is TokenState<'shadows'>;
    isShadowType(): this is TokenState<'shadowType'>;
    isSpacing(): this is TokenState<'spacing'>;
    isSpacings(): this is TokenState<'spacings'>;
    isStepsTimingFunction(): this is TokenState<'stepsTimingFunction'>;
    isTextAlignHorizontal(): this is TokenState<'textAlignHorizontal'>;
    isTextAlignVertical(): this is TokenState<'textAlignVertical'>;
    isTextDecoration(): this is TokenState<'textDecoration'>;
    isTextStyle(): this is TokenState<'textStyle'>;
    isTextTransform(): this is TokenState<'textTransform'>;
    isTransition(): this is TokenState<'transition'>;
    isVector(): this is TokenState<'vector'>;
    isVectorFormat(): this is TokenState<'vectorFormat'>;
    isZIndex(): this is TokenState<'zIndex'>;
}
