import { ResolvableModeLevelAlias, ResolvableTopLevelAlias, ResolvableValueLevelAlias, UnresolvableModeLevelAlias, UnresolvableTopLevelAlias, UnresolvableValueLevelAlias, } from './aliasing.js';
import { SDTFError } from '../../../errors/index.js';
/**
 * An InnerValue is a wrapper around the primitive value of a token that allows for
 * mapping over the different possible cases of the inner mode value, being value
 * level aliases or primitive values.
 */
export class InnerValue {
    #value;
    tokenState;
    constructor(value, tokenState) {
        this.#value = value;
        this.tokenState = tokenState;
    }
    _matchIsUnresolvableValueLevelAlias(v) {
        return v instanceof UnresolvableValueLevelAlias;
    }
    _matchIsResolvableValueLevelAlias(v) {
        return v instanceof ResolvableValueLevelAlias;
    }
    get isUnresolvableValueLevelAlias() {
        return this._matchIsUnresolvableValueLevelAlias(this.#value);
    }
    get isResolvableValueLevelAlias() {
        return this._matchIsResolvableValueLevelAlias(this.#value);
    }
    /**
     * Allows TypeScript to infer the type of the Value Level Alias.
     * @param type
     */
    ofType(type) {
        return this;
    }
    /**
     * Resolve the Value Level Alias to a raw value - returns Unresolvable aliases otherwise.
     */
    resolveDeepValue() {
        if (this._matchIsResolvableValueLevelAlias(this.#value)) {
            const { value: maybeRawValueOrUnresolvableAlias } = this.#value.tokenState.resolveDeepStatefulValueForMode(this.#value.targetMode);
            if (maybeRawValueOrUnresolvableAlias instanceof UnresolvableModeLevelAlias) {
                this.#value = new UnresolvableValueLevelAlias({
                    localMode: this.#value.localMode,
                    valuePath: this.#value.valuePath,
                    targetMode: maybeRawValueOrUnresolvableAlias.targetMode,
                    targetPath: maybeRawValueOrUnresolvableAlias.targetPath,
                });
            }
            else {
                this.#value = maybeRawValueOrUnresolvableAlias;
            }
        }
        return this;
    }
    /**
     * Map over the Unresolvable Value Level Alias case.
     * @param fn
     */
    mapUnresolvableValueLevelAlias(fn) {
        if (this._matchIsUnresolvableValueLevelAlias(this.#value)) {
            this.#value = fn(this.#value);
        }
        return this;
    }
    /**
     * Map over the Resolvable Value Level Alias case.
     * @param fn
     */
    mapResolvableValueLevelAlias(fn) {
        if (this._matchIsResolvableValueLevelAlias(this.#value)) {
            this.#value = fn(this.#value);
        }
        return this;
    }
    /**
     * Map over the raw value case.
     * Important: this method should be called first to avoid re-mapping
     * the mapUnresolvableValueLevelAlias and/or mapResolvableValueLevelAlias
     * returned values.
     * @param fn
     */
    mapPrimitiveValue(fn) {
        if (!this._matchIsResolvableValueLevelAlias(this.#value) &&
            !this._matchIsUnresolvableValueLevelAlias(this.#value)) {
            this.#value = fn(this.#value);
        }
        return this;
    }
    /**
     * Extract the mapped value.
     */
    unwrap() {
        return this.#value;
    }
    /**
     * Optimistically extract the mapped primitive value.
     */
    unwrapValue() {
        if (this._matchIsResolvableValueLevelAlias(this.#value)) {
            throw new SDTFError('SDTF_STATEFUL_VALUE_INVALID_VALUE_TYPE', `Cannot unwrap raw value of "${this.#value.tokenState.path}" because it is an alias.`);
        }
        if (this._matchIsUnresolvableValueLevelAlias(this.#value)) {
            throw new SDTFError('SDTF_STATEFUL_VALUE_INVALID_VALUE_TYPE', `Cannot unwrap raw value of "${this.#value.targetPath}" because it is an alias.`);
        }
        return this.#value;
    }
}
/**
 * A TopLevelValue is a wrapper around a token value that allows for
 * mapping over the different possible modes and cases of a locally defined token value.
 */
export class TopLevelValue {
    tokenState;
    // The first level is the same mode as the #value
    // And the second level mode is the one resolved by `resolveDeepValue`
    #currentTokenStateByMode;
    #value;
    constructor(value, tokenState) {
        this.#value = value;
        this.tokenState = tokenState;
        this.#currentTokenStateByMode = Object.keys(value).reduce((acc, mode) => {
            acc[mode] = { targetMode: mode, tokenState };
            return acc;
        }, {});
    }
    _matchIsUnresolvableModeLevelAlias(v) {
        return v instanceof UnresolvableModeLevelAlias;
    }
    _matchIsResolvableModeLevelAlias(v) {
        return v instanceof ResolvableModeLevelAlias;
    }
    _matchIsRawValue(v) {
        return !this._matchIsResolvableModeLevelAlias(v) && !this._matchIsUnresolvableModeLevelAlias(v);
    }
    /**
     * Test whether the token value has a mode.
     * @param mode
     */
    hasMode(mode) {
        return this.tokenState.modes.includes(mode);
    }
    /**
     * Filter the token value to only the given mode.
     * This method is primarily a performance optimization
     * to avoid iterating on all modes when only one is needed.
     * @param mode
     */
    focusOnMode(mode) {
        if (!this.hasMode(mode)) {
            throw new SDTFError('SDTF_STATEFUL_VALUE_UNKNOWN_MODE', `Mode "${mode}" is not defined in token "${this.tokenState.path}"`);
        }
        Object.keys(this.#value).forEach(key => {
            if (key !== mode)
                Reflect.deleteProperty(this.#value, key);
        });
        return this;
    }
    /**
     * Extract the mapped value for a given mode.
     * @param mode
     */
    pickMode(mode) {
        if (!this.hasMode(mode)) {
            throw new SDTFError('SDTF_STATEFUL_VALUE_UNKNOWN_MODE', `Mode "${mode}" is not defined in token "${this.tokenState.path}"`);
        }
        return this.#value[mode];
    }
    /**
     * Map over token value modes.
     * @param f
     */
    mapModes(f) {
        this.#value = Object.keys(this.#value).reduce((acc, mode) => {
            Reflect.set(acc, mode, f(mode));
            return acc;
        }, this.#value);
        return this;
    }
    /**
     * Deeply resolve the token value to a raw value - returns Unresolvable aliases otherwise.
     */
    resolveDeepValue() {
        this.#value = Object.entries(this.#value).reduce((acc, [mode, value]) => {
            if (this._matchIsResolvableModeLevelAlias(value)) {
                const { tokenState, value, targetMode: resolvedMode, } = this.tokenState.resolveDeepStatefulValueForMode(mode);
                Reflect.set(acc, mode, value);
                Reflect.set(this.#currentTokenStateByMode, mode, { targetMode: resolvedMode, tokenState });
            }
            return acc;
        }, this.#value);
        return this;
    }
    /**
     * Map over the Unresolvable Mode Level Alias case.
     * @param fn
     */
    mapUnresolvableModeLevelAlias(fn) {
        this.#value = Object.entries(this.#value).reduce((acc, [mode, value]) => {
            if (this._matchIsUnresolvableModeLevelAlias(value)) {
                Reflect.set(acc, mode, fn(value, mode));
            }
            return acc;
        }, this.#value);
        return this;
    }
    /**
     * Map over the Resolvable Mode Level Alias case.
     * @param fn
     */
    mapResolvableModeLevelAlias(fn) {
        this.#value = Object.entries(this.#value).reduce((acc, [mode, value]) => {
            if (this._matchIsResolvableModeLevelAlias(value)) {
                Reflect.set(acc, mode, fn(value, mode));
            }
            return acc;
        }, this.#value);
        return this;
    }
    /**
     * Map over the raw value case.
     * Important: this method should be called first to avoid re-mapping
     * the mapUnresolvableModeLevelAlias and/or mapResolvableModeLevelAlias
     * returned values.
     * @param fn
     */
    mapRawValue(fn) {
        this.#value = Object.entries(this.#value).reduce((acc, [mode, value]) => {
            if (this._matchIsRawValue(value)) {
                Reflect.set(acc, mode, fn(value, mode));
            }
            return acc;
        }, this.#value);
        return this;
    }
    /**
     * Map over the raw value case and pass the tokenState as well.
     * This method is useful after calling `resolveDeepValue` because the modes might point to a different tokenState
     * than the original. Note that the mode as well will be the one of the resolvedToken.
     * Important: this method should be called first to avoid re-mapping
     * the mapUnresolvableModeLevelAlias and/or mapResolvableModeLevelAlias
     * returned values.
     * @param fn
     */
    mapRawValueWithTokenState(fn) {
        this.#value = Object.entries(this.#value).reduce((acc, [mode, value]) => {
            if (this._matchIsRawValue(value)) {
                Reflect.set(acc, mode, fn(value, this.#currentTokenStateByMode[mode].targetMode, this.#currentTokenStateByMode[mode].tokenState));
            }
            return acc;
        }, this.#value);
        return this;
    }
    /**
     * Reduce the token value to an arbitrary output type.
     * @param f
     * @param initial
     */
    reduce(f, initial) {
        return Object.entries(this.#value).reduce((acc, [mode, value]) => f(acc, mode, value), initial);
    }
    /**
     * Extract the mapped value.
     */
    unwrap() {
        return this.#value;
    }
    /**
     * Optimistically extract the mapped value
     */
    unwrapValue() {
        return Object.entries(this.#value).reduce((acc, [key, value]) => {
            if (this._matchIsResolvableModeLevelAlias(this.#value[key])) {
                throw new SDTFError('SDTF_STATEFUL_VALUE_INVALID_VALUE_TYPE', `Cannot unwrap raw value of "${this.#value[key].tokenState.path}" because it is an alias.`);
            }
            if (this._matchIsUnresolvableModeLevelAlias(this.#value[key])) {
                throw new SDTFError('SDTF_STATEFUL_VALUE_INVALID_VALUE_TYPE', `Cannot unwrap raw value of "${this.#value[key].targetPath}" because it is an alias.`);
            }
            acc[key] = value;
            return acc;
        }, {});
    }
}
/**
 * A StatefulValueResult is a wrapper around a token value that allows for
 * mapping over the different possible cases of a token value.
 */
export class StatefulValueResult {
    tokenState;
    #value;
    constructor(value, tokenState) {
        this.#value = value;
        this.tokenState = tokenState;
    }
    _matchIsUnresolvableTopLevelAlias(v) {
        return v instanceof UnresolvableTopLevelAlias;
    }
    _matchIsResolvableTopLevelAlias(v) {
        return v instanceof ResolvableTopLevelAlias;
    }
    _matchIsTopLevelValue(v) {
        return v instanceof TopLevelValue;
    }
    get isUnresolvableTopLevelAlias() {
        return this._matchIsUnresolvableTopLevelAlias(this.#value);
    }
    get isResolvableTopLevelAlias() {
        return this._matchIsResolvableTopLevelAlias(this.#value);
    }
    get isTopLevelValue() {
        return this._matchIsTopLevelValue(this.#value);
    }
    /**
     * Deeply resolve the token value to a raw value - returns Unresolvable aliases otherwise.
     */
    resolveDeepValue() {
        if (this._matchIsResolvableTopLevelAlias(this.#value)) {
            this.#value = this.#value.tokenState.getStatefulValueResult().unwrap();
            this.resolveDeepValue();
        }
        return this;
    }
    /**
     * Map over the Unresolvable Top Level Alias case.
     * @param fn
     */
    mapUnresolvableTopLevelAlias(fn) {
        if (this._matchIsUnresolvableTopLevelAlias(this.#value)) {
            this.#value = fn(this.#value);
        }
        return this;
    }
    /**
     * Map over the Resolvable Top Level Alias case.
     * @param fn
     */
    mapResolvableTopLevelAlias(fn) {
        if (this._matchIsResolvableTopLevelAlias(this.#value)) {
            this.#value = fn(this.#value);
        }
        return this;
    }
    /**
     * Map over the locally defined value of the token wrapped in TopLevelValue.
     * @param fn
     */
    mapTopLevelValue(fn) {
        if (this._matchIsTopLevelValue(this.#value)) {
            this.#value = fn(this.#value);
        }
        return this;
    }
    /**
     * Extract the mapped value
     */
    unwrap() {
        return this.#value;
    }
    /**
     * Optimistically extract the mapped value at the mode level
     */
    unwrapValue() {
        if (this._matchIsResolvableTopLevelAlias(this.#value)) {
            throw new SDTFError('SDTF_STATEFUL_VALUE_INVALID_VALUE_TYPE', `Cannot unwrap raw value of "${this.#value.tokenState.path}" because it is an alias.`);
        }
        if (this._matchIsUnresolvableTopLevelAlias(this.#value)) {
            throw new SDTFError('SDTF_STATEFUL_VALUE_INVALID_VALUE_TYPE', `Cannot unwrap raw value of "${this.#value.targetPath}" because it is an alias.`);
        }
        return this.#value;
    }
}
