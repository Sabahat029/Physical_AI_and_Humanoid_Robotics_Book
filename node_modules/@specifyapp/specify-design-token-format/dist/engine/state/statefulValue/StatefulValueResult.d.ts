import { PickSpecifyDesignToken, SpecifyDesignTokenTypeName, SpecifyModeAndValueLevelAliasSignature } from '../../../definitions/index.js';
import { TokenState } from '../TokenState.js';
import { ResolvableModeLevelAlias, ResolvableTopLevelAlias, ResolvableValueLevelAlias, UnresolvableModeLevelAlias, UnresolvableTopLevelAlias, UnresolvableValueLevelAlias } from './aliasing.js';
/**
 * An InnerValue is a wrapper around the primitive value of a token that allows for
 * mapping over the different possible cases of the inner mode value, being value
 * level aliases or primitive values.
 */
export declare class InnerValue<T extends unknown = unknown, InitialRawType = Exclude<T, UnresolvableValueLevelAlias | ResolvableValueLevelAlias>, TypeOverride extends SpecifyDesignTokenTypeName = SpecifyDesignTokenTypeName> {
    #private;
    tokenState: TokenState;
    constructor(value: T, tokenState: TokenState);
    private _matchIsUnresolvableValueLevelAlias;
    private _matchIsResolvableValueLevelAlias;
    get isUnresolvableValueLevelAlias(): boolean;
    get isResolvableValueLevelAlias(): boolean;
    /**
     * Allows TypeScript to infer the type of the Value Level Alias.
     * @param type
     */
    ofType<TO extends SpecifyDesignTokenTypeName>(type: TO): InnerValue<RawValueSignature<TO>, RawValueSignature<TO>, TO>;
    /**
     * Resolve the Value Level Alias to a raw value - returns Unresolvable aliases otherwise.
     */
    resolveDeepValue(): InnerValue<Exclude<T, ResolvableValueLevelAlias>, InitialRawType, TypeOverride>;
    /**
     * Map over the Unresolvable Value Level Alias case.
     * @param fn
     */
    mapUnresolvableValueLevelAlias<U>(fn: (unresolvableAliasRef: Extract<T, UnresolvableValueLevelAlias>) => U): InnerValue<Exclude<T, UnresolvableValueLevelAlias> | U, InitialRawType, TypeOverride>;
    /**
     * Map over the Resolvable Value Level Alias case.
     * @param fn
     */
    mapResolvableValueLevelAlias<U>(fn: (resolvableAliasRef: ResolvableValueLevelAlias<TypeOverride>) => U): InnerValue<Exclude<T, ResolvableValueLevelAlias> | U, InitialRawType, TypeOverride>;
    /**
     * Map over the raw value case.
     * Important: this method should be called first to avoid re-mapping
     * the mapUnresolvableValueLevelAlias and/or mapResolvableValueLevelAlias
     * returned values.
     * @param fn
     */
    mapPrimitiveValue<U>(fn: (value: Exclude<T, ResolvableValueLevelAlias | UnresolvableValueLevelAlias>) => U): InnerValue<Exclude<T, Exclude<T, ResolvableValueLevelAlias | UnresolvableValueLevelAlias>> | U, InitialRawType, TypeOverride>;
    /**
     * Extract the mapped value.
     */
    unwrap(): T;
    /**
     * Optimistically extract the mapped primitive value.
     */
    unwrapValue(): Exclude<T, ResolvableValueLevelAlias | UnresolvableValueLevelAlias>;
}
type SwapAliasSignature<T> = T extends SpecifyModeAndValueLevelAliasSignature ? ResolvableValueLevelAlias | UnresolvableValueLevelAlias : T extends {
    [k: PropertyKey]: unknown;
} ? {
    [k in keyof T]: InnerValue<SwapAliasSignature<T[k]>>;
} : T extends Array<infer U> ? Array<InnerValue<SwapAliasSignature<U>>> : T;
export type RawValueSignature<Type extends SpecifyDesignTokenTypeName> = SwapAliasSignature<Exclude<PickSpecifyDesignToken<Type, string, true, false>['$value'], SpecifyModeAndValueLevelAliasSignature>>;
export type TopLevelValueSignature<Type extends SpecifyDesignTokenTypeName, R extends unknown = never> = {
    [mode: string]: ResolvableModeLevelAlias<Type> | UnresolvableModeLevelAlias | RawValueSignature<Type> | R;
};
/**
 * A TopLevelValue is a wrapper around a token value that allows for
 * mapping over the different possible modes and cases of a locally defined token value.
 */
export declare class TopLevelValue<Type extends SpecifyDesignTokenTypeName = SpecifyDesignTokenTypeName, T extends TopLevelValueSignature<Type, any> = TopLevelValueSignature<Type>> {
    #private;
    readonly tokenState: TokenState<Type>;
    constructor(value: TopLevelValueSignature<Type>, tokenState: TokenState<Type>);
    private _matchIsUnresolvableModeLevelAlias;
    private _matchIsResolvableModeLevelAlias;
    private _matchIsRawValue;
    /**
     * Test whether the token value has a mode.
     * @param mode
     */
    hasMode(mode: string): boolean;
    /**
     * Filter the token value to only the given mode.
     * This method is primarily a performance optimization
     * to avoid iterating on all modes when only one is needed.
     * @param mode
     */
    focusOnMode(mode: string): this;
    /**
     * Extract the mapped value for a given mode.
     * @param mode
     */
    pickMode(mode: string): T[number];
    /**
     * Map over token value modes.
     * @param f
     */
    mapModes<U>(f: (mode: string) => U): TopLevelValue<Type, {
        [mode: string]: U;
    }>;
    /**
     * Deeply resolve the token value to a raw value - returns Unresolvable aliases otherwise.
     */
    resolveDeepValue(): TopLevelValue<Type, {
        [mode: string]: Exclude<T[number], ResolvableModeLevelAlias<Type>>;
    }>;
    /**
     * Map over the Unresolvable Mode Level Alias case.
     * @param fn
     */
    mapUnresolvableModeLevelAlias<U>(fn: (unresolvableAliasRef: Extract<T[number], UnresolvableModeLevelAlias>, mode: string) => U): TopLevelValue<Type, {
        [mode: string]: U | Exclude<T[number], UnresolvableModeLevelAlias>;
    }>;
    /**
     * Map over the Resolvable Mode Level Alias case.
     * @param fn
     */
    mapResolvableModeLevelAlias<U>(fn: (resolvableAliasRef: Extract<T[number], ResolvableModeLevelAlias<Type>>, mode: string) => U): TopLevelValue<Type, {
        [mode: string]: U | Exclude<T[number], ResolvableModeLevelAlias<Type>>;
    }>;
    /**
     * Map over the raw value case.
     * Important: this method should be called first to avoid re-mapping
     * the mapUnresolvableModeLevelAlias and/or mapResolvableModeLevelAlias
     * returned values.
     * @param fn
     */
    mapRawValue<U>(fn: (rawValue: Exclude<T[number], UnresolvableModeLevelAlias | ResolvableModeLevelAlias<Type>>, mode: string) => U): TopLevelValue<Type, {
        [mode: string]: U | Exclude<T[number], RawValueSignature<Type>>;
    }>;
    /**
     * Map over the raw value case and pass the tokenState as well.
     * This method is useful after calling `resolveDeepValue` because the modes might point to a different tokenState
     * than the original. Note that the mode as well will be the one of the resolvedToken.
     * Important: this method should be called first to avoid re-mapping
     * the mapUnresolvableModeLevelAlias and/or mapResolvableModeLevelAlias
     * returned values.
     * @param fn
     */
    mapRawValueWithTokenState<U>(fn: (rawValue: Exclude<T[number], UnresolvableModeLevelAlias | ResolvableModeLevelAlias<Type>>, mode: string, tokenState: TokenState<Type>) => U): TopLevelValue<Type, {
        [mode: string]: U | Exclude<T[number], RawValueSignature<Type>>;
    }>;
    /**
     * Reduce the token value to an arbitrary output type.
     * @param f
     * @param initial
     */
    reduce<G>(f: (acc: G, mode: string, value: T[number]) => G, initial: G): G;
    /**
     * Extract the mapped value.
     */
    unwrap(): T;
    /**
     * Optimistically extract the mapped value
     */
    unwrapValue(): {
        [Key in keyof T]: Exclude<T[Key], ResolvableModeLevelAlias<Type> | UnresolvableModeLevelAlias>;
    };
}
/**
 * A StatefulValueResult is a wrapper around a token value that allows for
 * mapping over the different possible cases of a token value.
 */
export declare class StatefulValueResult<TokenType extends SpecifyDesignTokenTypeName = SpecifyDesignTokenTypeName, T extends unknown = ResolvableTopLevelAlias<TokenType> | UnresolvableTopLevelAlias | TopLevelValue<TokenType>> {
    #private;
    readonly tokenState: TokenState<TokenType>;
    constructor(value: T, tokenState: TokenState<TokenType>);
    private _matchIsUnresolvableTopLevelAlias;
    private _matchIsResolvableTopLevelAlias;
    private _matchIsTopLevelValue;
    get isUnresolvableTopLevelAlias(): boolean;
    get isResolvableTopLevelAlias(): boolean;
    get isTopLevelValue(): boolean;
    /**
     * Deeply resolve the token value to a raw value - returns Unresolvable aliases otherwise.
     */
    resolveDeepValue(): StatefulValueResult<TokenType, Exclude<T, ResolvableTopLevelAlias<TokenType>>>;
    /**
     * Map over the Unresolvable Top Level Alias case.
     * @param fn
     */
    mapUnresolvableTopLevelAlias<U extends unknown>(fn: (topLevelAliasRef: Extract<T, UnresolvableTopLevelAlias>) => U): StatefulValueResult<TokenType, U | Exclude<T, UnresolvableTopLevelAlias>>;
    /**
     * Map over the Resolvable Top Level Alias case.
     * @param fn
     */
    mapResolvableTopLevelAlias<U extends unknown>(fn: (topLevelAliasRef: Extract<T, ResolvableTopLevelAlias<TokenType>>) => U): StatefulValueResult<TokenType, U | Exclude<T, ResolvableTopLevelAlias<TokenType>>>;
    /**
     * Map over the locally defined value of the token wrapped in TopLevelValue.
     * @param fn
     */
    mapTopLevelValue<U extends unknown>(fn: (topLevelValue: TopLevelValue<TokenType>) => U): StatefulValueResult<TokenType, U | Exclude<T, TopLevelValue<TokenType>>>;
    /**
     * Extract the mapped value
     */
    unwrap(): T;
    /**
     * Optimistically extract the mapped value at the mode level
     */
    unwrapValue(): Exclude<T, ResolvableTopLevelAlias<TokenType> | UnresolvableTopLevelAlias>;
}
export {};
