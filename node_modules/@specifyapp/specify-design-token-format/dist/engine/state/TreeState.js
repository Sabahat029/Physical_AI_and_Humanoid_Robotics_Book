import { SDTFError } from '../../errors/index.js';
import { TokenState } from './TokenState.js';
import { GroupState } from './GroupState.js';
import { CollectionState } from './CollectionState.js';
import { setInSDTFTree } from '../utils/setInSDTFTree.js';
import { UnresolvableTokenState } from './UnresolvableTokenState.js';
import { ViewsState } from './ViewsState.js';
import { parseRawCollection } from '../parser/internals/parseRawCollection.js';
import { parseRawGroup } from '../parser/internals/parseRawGroup.js';
import { createTreeState } from '../builder/createTreeState.js';
import { parseRawToken } from '../parser/internals/parseRawToken.js';
import { computeDeepModesResolvability } from '../parser/internals/computeDeepModesResolvability.js';
import { analyzeValueAliasPart } from '../parser/internals/analyzeValueAliasPart.js';
import { TreeNodeSet } from './TreeNodeSet.js';
import { checkForTokenModesInCollection } from '../parser/internals/checkForTokenModesInCollection.js';
import { fillAliasReferences } from '../builder/fillAliasReferences.js';
import { TreePath } from './path/TreePath.js';
export class TreeState {
    global;
    aliasReferences;
    current;
    #viewsState;
    #activeViewName = null;
    constructor({ globalState, aliasReferences, viewsState, activeViewName }) {
        this.global = globalState;
        this.aliasReferences = aliasReferences;
        this.#viewsState = viewsState;
        this.#activeViewName = activeViewName;
        if (this.#activeViewName) {
            const maybeView = this.#viewsState.get(this.#activeViewName);
            if (!maybeView) {
                throw new SDTFError('SDTF_VIEW_NOT_FOUND', `View "${this.#activeViewName}" does not exist.`);
            }
            this.current = maybeView.nodes;
        }
        else {
            this.current = this.global;
        }
    }
    reset() {
        this.disableViews();
        this.global.clear();
        this.aliasReferences.clear();
        this.#viewsState.clear();
    }
    /* ------------------------------------------
       Views management
    --------------------------------------------- */
    refreshViews() {
        this.#viewsState.forEach(view => view.refresh(this));
    }
    listViews() {
        return this.#viewsState.values().map(view => ({
            name: view.name,
            query: view.query,
            isActive: view.name === this.#activeViewName,
        }));
    }
    getActiveView() {
        if (this.#activeViewName === null) {
            return null;
        }
        const maybeView = this.#viewsState.get(this.#activeViewName);
        /* v8 ignore next line */
        if (!maybeView)
            throw new SDTFError('SDTF_INTERNAL_DESIGN_ERROR', `View must exist.`);
        return maybeView.serialize();
    }
    registerView(name, query, shouldSetActive) {
        this.#viewsState.register(name, query, this);
        if (shouldSetActive === true) {
            const view = this.#viewsState.get(name);
            if (!view) {
                throw new SDTFError('SDTF_VIEW_NOT_FOUND', `View "${name}" does not exist.`);
            }
            this.#activeViewName = name;
            this.current = view.nodes;
        }
    }
    updateView(name, query, shouldSetActive) {
        this.#viewsState.updateQuery(name, query, this);
        if (shouldSetActive === true) {
            const view = this.#viewsState.get(name);
            if (!view) {
                throw new SDTFError('SDTF_VIEW_NOT_FOUND', `View "${name}" does not exist.`);
            }
            this.#activeViewName = name;
            this.current = view.nodes;
        }
    }
    setActiveView(name) {
        if (name === null) {
            this.disableViews();
        }
        else {
            if (!this.#viewsState.has(name)) {
                throw new SDTFError('SDTF_VIEW_NOT_FOUND', `View "${name}" does not exist.`);
            }
            this.#activeViewName = name;
            const viewState = this.#viewsState.get(name);
            this.current = viewState.nodes;
        }
    }
    deleteView(name) {
        if (this.#activeViewName === name) {
            this.#activeViewName = null;
            this.current = this.global;
        }
        return this.#viewsState.delete(name);
    }
    deleteAllViews() {
        this.#activeViewName = null;
        this.current = this.global;
        this.#viewsState.clear();
    }
    disableViews() {
        this.current = this.global;
        this.#activeViewName = null;
    }
    withViewNodesState(viewName, fn) {
        if (viewName === undefined) {
            return fn(this.current);
        }
        if (viewName === null) {
            return fn(this.global);
        }
        const maybeView = this.#viewsState.get(viewName);
        if (!maybeView) {
            throw new SDTFError('SDTF_VIEW_NOT_FOUND', `View "${viewName}" does not exist.`);
        }
        return fn(maybeView.nodes);
    }
    /* ------------------------------------------
       Aliases management
    --------------------------------------------- */
    addAliasReference(candidate) {
        const hasReference = this.aliasReferences.hasFrom(candidate.from);
        if (!hasReference) {
            this.aliasReferences.add(candidate);
        }
        else {
            throw new SDTFError('SDTF_CIRCULAR_ALIAS_REFERENCE_FOUND', `Reference to "${candidate.from.valuePath}" is circular.`);
        }
    }
    updateAliasReference(at, candidate) {
        this.aliasReferences.updateAtFrom(at, candidate);
    }
    upsertAliasReference(candidate) {
        this.aliasReferences.upsertAtFrom(candidate);
    }
    getAliasReference(from) {
        return this.aliasReferences.getOne(from);
    }
    getAllAliasReferences() {
        return Array.from(this.aliasReferences);
    }
    getAliasReferencesTo(to, options) {
        return this.aliasReferences.getManyTo(to, options);
    }
    getAliasReferencesFrom(from, options) {
        return this.aliasReferences.getManyFrom(from, options);
    }
    getDeepAliasReferencesFrom(from) {
        return this.aliasReferences.getOneDeepFrom(from);
    }
    getAliasReferenceOrParentFrom(from) {
        return this.aliasReferences.getOneOrParentFrom(from);
    }
    /**
     * Retrieve the target coordinates from a starting point.
     * E.g, if you want the value of a dimension, it'll tell you where is the JSON value.
     * It'll be either on a number token, or the value of a dimension token.
     */
    getDeepAliasReferenceAndPathInfoFrom(from) {
        return this.aliasReferences.getOneDeepAndPathInfosFrom(from);
    }
    deleteAliasReferencesFrom(from) {
        return this.aliasReferences.deleteManyFrom(from);
    }
    getStatefulAliasReference(from) {
        const maybeAlias = this.aliasReferences.getOne(from);
        if (!maybeAlias) {
            return {
                status: 'unresolvable',
                from,
                to: {
                    treePath: TreePath.empty(),
                    mode: null,
                },
                unresolvableTokenState: new UnresolvableTokenState(this, TreePath.empty(), 'Unknown alias reference'),
            };
        }
        const maybeTokenState = this.getTokenState(maybeAlias.to.treePath, { withView: null });
        if (maybeTokenState) {
            return {
                status: 'resolved',
                from,
                to: maybeAlias.to,
                tokenState: maybeTokenState,
            };
        }
        return {
            status: 'unresolvable',
            from,
            to: maybeAlias.to,
            unresolvableTokenState: new UnresolvableTokenState(this, maybeAlias.to.treePath, `Could not find token "${maybeAlias.to.treePath}".`),
        };
    }
    getStatefulAliasReferencesTo(to, options) {
        return this.aliasReferences.getManyTo(to, options).map(reference => {
            const { isResolvable, from, to } = reference;
            if (isResolvable) {
                const maybeTokenState = this.getTokenState(from.treePath, { withView: null });
                if (maybeTokenState) {
                    return {
                        status: 'resolved',
                        from,
                        to,
                        tokenState: maybeTokenState,
                    };
                }
                else {
                    throw new SDTFError('SDTF_INTERNAL_DESIGN_ERROR', `Could not find token "${from.treePath}".`);
                }
            }
            else {
                return {
                    status: 'unresolvable',
                    from,
                    to,
                    unresolvableTokenState: new UnresolvableTokenState(this, from.treePath, reference.reason),
                };
            }
        });
    }
    getStatefulAliasReferencesFrom(from, options) {
        return this.aliasReferences.getManyFrom(from, options).map(reference => {
            const { isResolvable, from, to } = reference;
            if (isResolvable) {
                const maybeTokenState = this.getTokenState(to.treePath, { withView: null });
                if (maybeTokenState) {
                    return {
                        status: 'resolved',
                        from,
                        to,
                        tokenState: maybeTokenState,
                    };
                }
                else {
                    throw new SDTFError('SDTF_INTERNAL_DESIGN_ERROR', `Could not find token "${to.treePath}".`);
                }
            }
            else {
                return {
                    status: 'unresolvable',
                    from,
                    to,
                    unresolvableTokenState: new UnresolvableTokenState(this, to.treePath, reference.reason),
                };
            }
        });
    }
    deleteOneAliasReference(from) {
        this.aliasReferences.deleteOne(from);
    }
    /* ------------------------------------------
       Nodes management
    --------------------------------------------- */
    isAvailablePath(path) {
        return (!this.global.tokens.has(path.toString()) &&
            !this.global.groups.has(path.toString()) &&
            !this.global.collections.has(path.toString()));
    }
    isExistingParentPath(path) {
        const parentPath = path.makeParentPath();
        return parentPath.isRoot ? true : !this.isAvailablePath(parentPath);
    }
    updateChildrenPaths(parentPath, replacer) {
        const atIndex = parentPath.length - 1;
        this.getChildrenOf(parentPath, undefined, { withView: null }).forEach(child => {
            child.updatePathItem(atIndex, replacer);
        });
    }
    addCollection(path, collectionProperties) {
        if (!this.isAvailablePath(path)) {
            throw new SDTFError('SDTF_PATH_ALREADY_TAKEN', `Path "${path}" is already used.`);
        }
        if (!this.isExistingParentPath(path)) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Parent path for "${path}" does not exist.`);
        }
        const maybeCollectionState = this.getNearestCollectionState(path, { withView: null });
        if (maybeCollectionState) {
            throw new SDTFError('SDTF_NESTED_COLLECTION', `Collection "${path}" is nested in collection "${maybeCollectionState.path.toString()}".`);
        }
        const analyzedCollection = parseRawCollection(path, collectionProperties);
        const collectionState = new CollectionState(this, analyzedCollection);
        this.global.collections.add(collectionState);
        this.refreshViews();
    }
    renameCollection(path, newName) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        maybeCollectionState.rename(newName);
        this.refreshViews();
    }
    updateCollectionDescription(path, newDescription) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        maybeCollectionState.updateDescription(newDescription);
        this.refreshViews();
    }
    updateCollectionExtensions(path, newExtensions) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        maybeCollectionState.updateExtensions(newExtensions);
    }
    renameCollectionMode(path, fromMode, toMode) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        maybeCollectionState.renameMode(fromMode, toMode);
        this.refreshViews();
    }
    deleteCollectionMode(path, mode) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        maybeCollectionState.deleteMode(mode);
        this.refreshViews();
    }
    deleteCollection(path) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        // Delete enclosed groups
        this.global.groups.getChildrenOf(path).forEach(group => {
            try {
                this.deleteGroup(group.path);
            }
            catch (error) {
                if (!(error instanceof SDTFError) ||
                    (error instanceof SDTFError && error.errorKey !== 'SDTF_TREE_NODE_NOT_FOUND')) {
                    throw error;
                }
            }
        });
        // Delete enclosed tokens
        this.global.tokens.getChildrenOf(path).forEach(token => {
            try {
                this.deleteToken(token.path);
            }
            catch (error) {
                if (!(error instanceof SDTFError) ||
                    (error instanceof SDTFError && error.errorKey !== 'SDTF_TREE_NODE_NOT_FOUND')) {
                    throw error;
                }
            }
        });
        // Delete collection
        this.global.collections.delete(path.toString());
        this.refreshViews();
    }
    moveCollection(atPath, toPath) {
        const maybeCollectionState = this.global.collections.getOne(atPath.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${atPath}" does not exist.`);
        }
        maybeCollectionState.move(toPath);
        // views update is managed by the move method
    }
    truncateCollection(path) {
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (!maybeCollectionState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Collection "${path}" does not exist.`);
        }
        // Delete enclosed groups
        this.global.groups.getChildrenOf(path).forEach(group => {
            this.deleteGroup(group.path);
        });
        // Delete enclosed tokens
        this.global.tokens.getChildrenOf(path).forEach(token => {
            this.deleteToken(token.path);
        });
        this.refreshViews();
    }
    addGroup(path, groupProperties) {
        if (!this.isAvailablePath(path)) {
            throw new SDTFError('SDTF_PATH_ALREADY_TAKEN', `Path "${path}" is already used.`);
        }
        if (!this.isExistingParentPath(path)) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Parent path for "${path}" does not exist.`);
        }
        const analyzedGroup = parseRawGroup(path, groupProperties);
        const groupState = new GroupState(this, analyzedGroup);
        this.global.groups.add(groupState);
        this.refreshViews();
    }
    renameGroup(path, newName) {
        const maybeGroupState = this.global.groups.getOne(path.toString());
        if (!maybeGroupState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Group "${path}" does not exist.`);
        }
        maybeGroupState.rename(newName);
        this.refreshViews();
    }
    updateGroupDescription(path, newDescription) {
        const maybeGroupState = this.global.groups.getOne(path.toString());
        if (!maybeGroupState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Group "${path}" does not exist.`);
        }
        maybeGroupState.updateDescription(newDescription);
        this.refreshViews();
    }
    updateGroupExtensions(path, newExtensions) {
        const maybeGroupState = this.global.groups.getOne(path.toString());
        if (!maybeGroupState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Group "${path}" does not exist.`);
        }
        maybeGroupState.updateExtensions(newExtensions);
    }
    deleteGroup(path) {
        const maybeGroupState = this.global.groups.getOne(path.toString());
        if (!maybeGroupState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Group "${path}" does not exist.`);
        }
        // Delete enclosed collections
        this.global.collections.getChildrenOf(path).forEach(collection => {
            try {
                this.deleteCollection(collection.path);
            }
            catch (error) {
                if (!(error instanceof SDTFError) ||
                    (error instanceof SDTFError && error.errorKey !== 'SDTF_TREE_NODE_NOT_FOUND')) {
                    throw error;
                }
            }
        });
        // Delete enclosed groups
        this.global.groups.getChildrenOf(path).forEach(group => {
            try {
                this.deleteGroup(group.path);
            }
            catch (error) {
                if (!(error instanceof SDTFError) ||
                    (error instanceof SDTFError && error.errorKey !== 'SDTF_TREE_NODE_NOT_FOUND')) {
                    throw error;
                }
            }
        });
        // Delete enclosed tokens
        this.global.tokens.getChildrenOf(path).forEach(token => {
            try {
                this.deleteToken(token.path);
            }
            catch (error) {
                if (!(error instanceof SDTFError) ||
                    (error instanceof SDTFError && error.errorKey !== 'SDTF_TREE_NODE_NOT_FOUND')) {
                    throw error;
                }
            }
        });
        // Delete group
        this.global.groups.delete(path.toString());
        this.refreshViews();
    }
    moveGroup(atPath, toPath) {
        const maybeGroupState = this.global.groups.getOne(atPath.toString());
        if (!maybeGroupState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Group "${atPath}" does not exist.`);
        }
        maybeGroupState.move(toPath);
        // views update is managed by the move method
    }
    truncateGroup(path) {
        const maybeGroupState = this.global.groups.getOne(path.toString());
        if (!maybeGroupState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Group "${path}" does not exist.`);
        }
        // Delete enclosed collections
        this.global.collections.getChildrenOf(path).forEach(collection => {
            this.deleteCollection(collection.path);
        });
        // Delete enclosed groups
        this.global.groups.getChildrenOf(path).forEach(group => {
            this.deleteGroup(group.path);
        });
        // Delete enclosed tokens
        this.global.tokens.getChildrenOf(path).forEach(token => {
            this.deleteToken(token.path);
        });
    }
    addToken(path, rawToken) {
        if (!this.isAvailablePath(path)) {
            throw new SDTFError('SDTF_PATH_ALREADY_TAKEN', `Path "${path}" is already used.`);
        }
        if (!this.isExistingParentPath(path)) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Parent path for "${path}" does not exist.`);
        }
        const analyzedToken = parseRawToken(path, rawToken);
        const analyzedTokens = new TreeNodeSet(this.global.tokens.all.map(n => n.toAnalyzedToken()));
        analyzedTokens.add(analyzedToken);
        analyzedToken.analyzedValueAliasParts.forEach(aliasPart => {
            aliasPart.isResolvable = analyzeValueAliasPart(analyzedToken, aliasPart, analyzedTokens);
        });
        computeDeepModesResolvability(analyzedToken.path.toString(), analyzedTokens);
        /* v8 ignore start */
        if (analyzedToken.modesResolvability === undefined ||
            analyzedToken.isFullyResolvable === undefined) {
            throw new SDTFError('SDTF_INTERNAL_DESIGN_ERROR', `Token ${analyzedToken.path} has no modesResolvability defined`);
        }
        /* v8 ignore stop */
        const isFullyResolvable = analyzedToken.isFullyResolvable;
        const modesResolvabilityMap = new Map(Object.entries(analyzedToken.modesResolvability));
        const maybeCollectionState = this.getNearestCollectionState(path, { withView: null });
        if (maybeCollectionState) {
            const tokenModes = analyzedToken.computedModes ?? analyzedToken.modes;
            checkForTokenModesInCollection(analyzedToken.path.toString(), tokenModes, maybeCollectionState.path.toString(), maybeCollectionState.allowedModes);
        }
        const tokenState = new TokenState(this, {
            path: analyzedToken.path,
            name: analyzedToken.name,
            $type: analyzedToken.$type,
            $description: analyzedToken.$description,
            $extensions: analyzedToken.$extensions,
            isTopLevelAlias: analyzedToken.isTopLevelAlias,
            definition: analyzedToken.definition,
            analyzedValuePrimitiveParts: analyzedToken.analyzedValuePrimitiveParts,
            isFullyResolvable,
            modesResolvabilityMap,
        });
        this.global.tokens.add(tokenState);
        fillAliasReferences(analyzedToken, tokenState, this.aliasReferences, (stringPath) => {
            /* v8 ignore next 12 */
            const maybeTokenState = this.getTokenState(TreePath.fromString(stringPath), {
                withView: null,
            });
            if (!maybeTokenState)
                throw new SDTFError('SDTF_INTERNAL_DESIGN_ERROR', `Token reference "${path.toString()}" not found`);
            return maybeTokenState;
        });
        this.refreshViews();
    }
    renameToken(path, newName) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.rename(newName);
        this.refreshViews();
    }
    updateTokenDescription(path, newDescription) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.updateDescription(newDescription);
        this.refreshViews();
    }
    updateTokenExtensions(path, newExtensions) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.updateExtensions(newExtensions);
    }
    updateTokenValue(path, newValue) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.updateValue(newValue);
        this.refreshViews();
    }
    resolveTokenValueAliases(path) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.resolveValueAliases();
    }
    updateTokenModeValue(path, mode, newValue) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.updateModeValue(mode, newValue);
    }
    renameTokenMode(path, fromMode, toMode) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        maybeTokenState.renameMode(fromMode, toMode);
        this.refreshViews();
    }
    createTokenModeValue(path, mode, value) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState)
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        maybeTokenState.createModeValue(mode, value);
        this.refreshViews();
    }
    deleteTokenModeValue(path, mode) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState)
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        maybeTokenState.deleteModeValue(mode);
        this.refreshViews();
    }
    deleteToken(path) {
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${path}" does not exist.`);
        }
        // Delete aliases references from the token
        this.aliasReferences.deleteManyFrom({ treePath: maybeTokenState.path });
        // Unlink aliases references to the token
        this.aliasReferences.unlinkManyTo({ treePath: maybeTokenState.path });
        // Delete token
        this.global.tokens.delete(path.toString());
        this.refreshViews();
    }
    moveToken(fromPath, toPath) {
        const maybeTokenState = this.global.tokens.getOne(fromPath.toString());
        if (!maybeTokenState) {
            throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Token "${fromPath}" does not exist.`);
        }
        maybeTokenState.move(toPath);
        // views update is managed by the move method
    }
    renameNode(path, newName) {
        const maybeGroupState = this.global.groups.getOne(path.toString());
        if (maybeGroupState) {
            maybeGroupState.rename(newName);
            this.refreshViews();
            return;
        }
        const maybeTokenState = this.global.tokens.getOne(path.toString());
        if (maybeTokenState) {
            maybeTokenState.rename(newName);
            this.refreshViews();
            return;
        }
        const maybeCollectionState = this.global.collections.getOne(path.toString());
        if (maybeCollectionState) {
            maybeCollectionState.rename(newName);
            this.refreshViews();
            return;
        }
        throw new SDTFError('SDTF_TREE_NODE_NOT_FOUND', `Node "${path}" does not exist.`);
    }
    /* ------------------------------------------
       Getters
    --------------------------------------------- */
    getTokenState(path, options) {
        return this.withViewNodesState(options?.withView, nodes => {
            return nodes.tokens.getOne(path.toString());
        });
    }
    getGroupState(path, options) {
        return this.withViewNodesState(options?.withView, nodes => {
            return nodes.groups.getOne(path.toString());
        });
    }
    getCollectionState(path, options) {
        return this.withViewNodesState(options?.withView, nodes => {
            return nodes.collections.getOne(path.toString());
        });
    }
    getNearestCollectionState(path, options) {
        for (let i = path.length - 1; i >= 0; i--) {
            const computedPath = path.slice(0, i);
            const maybeCollectionState = this.getCollectionState(computedPath, options);
            if (maybeCollectionState) {
                return maybeCollectionState;
            }
        }
        return undefined;
    }
    getAllTokenStates(options) {
        return this.withViewNodesState(options?.withView, nodes => Array.from(nodes.tokens));
    }
    getAllGroupStates(options) {
        return this.withViewNodesState(options?.withView, nodes => Array.from(nodes.groups));
    }
    getAllCollectionStates(options) {
        return this.withViewNodesState(options?.withView, nodes => Array.from(nodes.collections));
    }
    getAllNodeStates(options) {
        return this.withViewNodesState(options?.withView, nodes => [...nodes.groups, ...nodes.collections, ...nodes.tokens].sort((nodeA, nodeB) => {
            return nodeA.path.toString().localeCompare(nodeB.path.toString());
        }));
    }
    getTokenChildrenOf(path, depth, options) {
        return this.withViewNodesState(options?.withView, nodes => nodes.tokens.getChildrenOf(path, depth));
    }
    getGroupChildrenOf(path, depth, options) {
        return this.withViewNodesState(options?.withView, nodes => nodes.groups.getChildrenOf(path, depth));
    }
    getCollectionChildrenOf(path, depth, options) {
        return this.withViewNodesState(options?.withView, nodes => nodes.collections.getChildrenOf(path, depth));
    }
    getChildrenOf(path, depth, options) {
        return this.withViewNodesState(options?.withView, nodes => {
            return [
                ...nodes.groups.getChildrenOf(path, depth),
                ...nodes.collections.getChildrenOf(path, depth),
                ...nodes.tokens.getChildrenOf(path, depth),
            ].sort((nodeA, nodeB) => {
                return nodeA.path.toString().localeCompare(nodeB.path.toString());
            });
        });
    }
    getParentsOf(path, depth, options) {
        return this.withViewNodesState(options?.withView, nodes => {
            return [
                ...nodes.groups.getParentsOf(path, depth),
                ...nodes.collections.getParentsOf(path, depth),
                ...nodes.tokens.getParentsOf(path, depth),
            ].sort((nodeA, nodeB) => {
                return nodeB.path.toString().localeCompare(nodeA.path.toString());
            });
        });
    }
    getGroupChildren(options) {
        return this.getGroupChildrenOf(TreePath.empty(), 1, options);
    }
    getTokenChildren(options) {
        return this.getTokenChildrenOf(TreePath.empty(), 1, options);
    }
    getCollectionChildren(options) {
        return this.getCollectionChildrenOf(TreePath.empty(), 1, options);
    }
    /* ------------------------------------------
       Exporters
    --------------------------------------------- */
    clone() {
        const analyzedTokenTree = this.global.toAnalyzedTokenTree();
        const serializedViews = this.#viewsState.serialize();
        const viewsState = new ViewsState();
        const newTreeState = createTreeState(analyzedTokenTree, {
            viewsState,
        });
        serializedViews.forEach(view => {
            viewsState.register(view.name, view.query, newTreeState);
        });
        if (this.#activeViewName !== null) {
            newTreeState.setActiveView(this.#activeViewName);
        }
        return newTreeState;
    }
    populateJSONChildrenOf(path, accumulator, renderOptions) {
        const nodes = this.getChildrenOf(path, undefined, { withView: null });
        nodes.forEach(node => {
            const computedPath = node.path.slice(path.length);
            if (node.isGroup) {
                setInSDTFTree(accumulator, computedPath, node.getJSONProperties());
            }
            else if (node.isCollection) {
                setInSDTFTree(accumulator, computedPath, node.getJSONProperties());
            }
            else if (node) {
                setInSDTFTree(accumulator, computedPath, node.getJSONToken(renderOptions ??
                    { resolveAliases: false }));
            }
        });
    }
    renderJSONTree(renderOptions) {
        if (renderOptions?.resolveAliases && renderOptions?.targetMode) {
            throw new SDTFError('SDTF_INVALID_OPTION', 'The "targetMode" option is not supported when using renderJSONTree.');
        }
        const tree = {};
        this.populateJSONChildrenOf(TreePath.empty(), tree, renderOptions);
        return tree;
    }
    exportMetadata() {
        return {
            activeViewName: this.#activeViewName,
            views: this.#viewsState.values().map(v => v.serialize()),
        };
    }
    exportAll() {
        return {
            tokenTree: this.renderJSONTree(),
            metadata: this.exportMetadata(),
        };
    }
    toJSON() {
        return this.renderJSONTree();
    }
}
