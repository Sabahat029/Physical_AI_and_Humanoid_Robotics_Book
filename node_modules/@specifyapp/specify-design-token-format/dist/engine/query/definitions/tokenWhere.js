import { z } from 'zod';
import { childrenAndParentsUpToDepthOperatorSchema } from '../internals/childrenAndParentsUpToDepthOperator.js';
import { nodePropertiesMatchingSchema } from '../internals/nodePropertiesMatching.js';
import { withModesSchema } from '../internals/withModes.js';
import { withTypesSchema } from '../internals/withTypes.js';
import { nodeWithAtDepthSchema } from '../internals/nodeAtDepthProperty.js';
export const groupParentsOfTokenUpToDepthOperatorSchema = z.union([
    z
        .object({
        upToDepth: z.union([z.number().min(0), z.literal('collection')]),
        equalToDepth: z.undefined(),
    })
        .strict(),
    z
        .object({
        upToDepth: z.undefined(),
        equalToDepth: z.number().min(0),
    })
        .strict(),
]);
export const collectionParentsOfTokenUpToDepthOperatorSchema = z.union([
    z
        .object({
        upToDepth: z.union([z.number().min(0), z.literal('group')]),
        equalToDepth: z.undefined(),
    })
        .strict(),
    z
        .object({
        upToDepth: z.undefined(),
        equalToDepth: z.number().min(0),
    })
        .strict(),
]);
export const tokenSelectSchema = z
    .object({
    token: z.boolean().optional(),
    parents: z
        .union([
        z.literal(true),
        childrenAndParentsUpToDepthOperatorSchema,
        z
            .object({
            groups: z
                .union([z.literal(true), groupParentsOfTokenUpToDepthOperatorSchema])
                .optional(),
            collections: z
                .union([z.literal(true), collectionParentsOfTokenUpToDepthOperatorSchema])
                .optional(),
        })
            .strict(),
    ])
        .optional(),
})
    .strict()
    .refine(value => {
    return !(value.parents === undefined && value.token === undefined);
}, {
    message: 'Select must include either `parents` or `token`',
    path: [],
});
const tokenSelectPropertySchema = z.union([z.literal(true), tokenSelectSchema]);
const tokenWithSelectSchema = z.object({
    select: tokenSelectPropertySchema,
});
const tokenNestedInPropertySchema = z.object({
    collection: z.boolean().optional(),
    group: z.boolean().optional(),
});
const tokenWithNestedInSchema = z.object({
    nestedIn: tokenNestedInPropertySchema.optional(),
});
const tokenContainsAliasesSchema = z
    .union([
    z.boolean(),
    z
        .object({
        level: z.union([z.literal('all'), z.literal('mode'), z.literal('value')]).optional(),
        resolvability: z
            .union([z.literal('all'), z.literal('unresolvable'), z.literal('resolvable')])
            .optional(),
    })
        .strict(),
])
    .optional();
const tokenWithContainsAliasesSchema = z.object({
    containsAliases: tokenContainsAliasesSchema,
});
const tokenSourcesSchema = z
    .union([
    z.object({ include: z.array(z.string().uuid()) }).strict(),
    z.object({ exclude: z.array(z.string().uuid()) }).strict(),
])
    .optional();
const tokenWithSourcesSchema = z.object({
    withSourceIds: tokenSourcesSchema,
});
const tokenCreatedSchema = z
    .object({
    from: z.string().datetime().optional(),
    to: z.string().datetime().optional(),
})
    .optional();
const tokenWithCreatedSchema = z.object({
    created: tokenCreatedSchema,
});
const tokenUpdatedSchema = z
    .object({
    from: z.string().datetime().optional(),
    to: z.string().datetime().optional(),
})
    .optional();
const tokenWithUpdatedSchema = z.object({
    updated: tokenUpdatedSchema,
});
const tokenWithSelfSelectorSchema = z.object({
    token: nodePropertiesMatchingSchema,
});
export const tokenWhereSchema = tokenWithSelfSelectorSchema
    .merge(withModesSchema)
    .merge(withTypesSchema)
    .merge(nodeWithAtDepthSchema)
    .merge(tokenWithSelectSchema)
    .merge(tokenWithNestedInSchema)
    .merge(tokenWithContainsAliasesSchema)
    .merge(tokenWithSourcesSchema)
    .merge(tokenWithCreatedSchema)
    .merge(tokenWithUpdatedSchema);
export function matchIsTokenWhere(where) {
    return 'token' in where;
}
