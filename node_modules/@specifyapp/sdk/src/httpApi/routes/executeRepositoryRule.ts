import { z } from 'zod';
import { specifyConfigurationV2RuleSchema } from '../../configurationFile/definitions.js';
import { HttpResponseBody } from '../internals/httpResponseBody.js';
import { PipeEngineRuleResult } from '../../pipeEngine/index.js';
import { createPublicHttpRouteDefinition } from '../internals/createPublicHttpRouteDefinition.js';
import { ParserOutput } from '../../parsersEngine/index.js';

export function makeExecuteRepositoryRuleRoute(options?: { owner: string; name: string }) {
  const { owner, name } = options ?? {};
  return `/v2/${owner ?? '{owner}'}/repository/${name ?? '{name}'}/execute-rule`;
}

export const executeRepositoryRuleRouteDefinition = createPublicHttpRouteDefinition({
  httpMethod: 'POST' as const,
  authenticationStrategy: 'personalAccessToken' as const,
  makeRoute: makeExecuteRepositoryRuleRoute,
  responsePayloadSchema: z
    .object({
      fromRule: z.string(),
      output: z.custom<ParserOutput>(v => v),
    })
    .strict(),
  paramsSchema: z
    .object({
      owner: z.string().min(1),
      name: z.string().min(1),
    })
    .strict(),
  requestBodySchema: specifyConfigurationV2RuleSchema,
});

export type ExecuteRepositoryRuleRequestBody = z.infer<typeof specifyConfigurationV2RuleSchema>;

type SucceededPipeEngineRepositoryRuleResult = Extract<PipeEngineRuleResult, { status: 'success' }>;
export type ExecuteRepositoryRuleResponsePayload = {
  fromRule: SucceededPipeEngineRepositoryRuleResult['fromRule'];
  output: SucceededPipeEngineRepositoryRuleResult['value'];
};

export type ExecuteRepositoryRuleResponseBody<
  Status extends 'success' | 'error' = 'success' | 'error',
> = Extract<HttpResponseBody<ExecuteRepositoryRuleResponsePayload>, { status: Status }>;
