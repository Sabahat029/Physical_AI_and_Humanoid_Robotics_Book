import { SpecifyError, specifyErrors } from '../errors/index.js';
import { ParserFunction } from './definitions/ParserFunction.js';
import { ParsersEngineDataBox } from './definitions/parsersEngineDataBox.js';
import { ParserToolbox } from './ParserToolbox.js';

export function chainParserFunctions<
  A extends ParsersEngineDataBox,
  B extends ParsersEngineDataBox,
>(ab: ParserFunction<A, B>): ParserFunction<A, B>;
export function chainParserFunctions<
  A extends ParsersEngineDataBox,
  B extends ParsersEngineDataBox,
  C extends ParsersEngineDataBox,
>(ab: ParserFunction<A, B>, bc: ParserFunction<B, C>): ParserFunction<A, C>;
export function chainParserFunctions<
  A extends ParsersEngineDataBox,
  B extends ParsersEngineDataBox,
  C extends ParsersEngineDataBox,
  D extends ParsersEngineDataBox,
>(
  ab: ParserFunction<A, B>,
  bc: ParserFunction<B, C>,
  cd: ParserFunction<C, D>,
): ParserFunction<A, D>;
export function chainParserFunctions<
  A extends ParsersEngineDataBox,
  B extends ParsersEngineDataBox,
  C extends ParsersEngineDataBox,
  D extends ParsersEngineDataBox,
  E extends ParsersEngineDataBox,
>(
  ab: ParserFunction<A, B>,
  bc: ParserFunction<B, C>,
  cd: ParserFunction<C, D>,
  de: ParserFunction<D, E>,
): ParserFunction<A, E>;
export function chainParserFunctions<
  A extends ParsersEngineDataBox,
  B extends ParsersEngineDataBox,
  C extends ParsersEngineDataBox,
  D extends ParsersEngineDataBox,
  E extends ParsersEngineDataBox,
  F extends ParsersEngineDataBox,
>(
  ab: ParserFunction<A, B>,
  bc: ParserFunction<B, C>,
  cd: ParserFunction<C, D>,
  de: ParserFunction<D, E>,
  ef: ParserFunction<E, F>,
): ParserFunction<A, F>;
/**
 * Creates a pipeline of Parser functions that will be sequentially executed SDTF -> A -> B -> C...
 * Each Parser function must implement the ParserFunction signature: (data: ParsersEngineDataBox, toolbox: ParserToolbox) => Promise<ParsersEngineDataBox>
 * @example
 * const pipeline = chainParserFunctions(
 *   parsers.svgo(),
 *   parsers.svgToJsx({ output: { type: ... } }),
 *   async (dataBox, toolbox) => {
 *     // custom code
 *     return dataBox;
 *   }
 * );
 * @param parserFunctions
 */
export function chainParserFunctions(...parserFunctions: ParserFunction[]) {
  if (!parserFunctions || parserFunctions.length === 0) {
    throw new SpecifyError({
      errorKey: specifyErrors.PARSERS_ENGINE_PARSER_EXECUTION_FAILED.errorKey,
      publicMessage: `No parsers provided to chainParserFunctions.`,
    });
  }

  // We use a named function to allow execution/debug to capture the function name
  async function executeParsersPipeline(dataBox: ParsersEngineDataBox, toolbox: ParserToolbox) {
    let result: ParsersEngineDataBox = dataBox;
    for (const parser of parserFunctions) {
      result = await parser(result, toolbox);
    }
    return result;
  }
  return executeParsersPipeline;
}
