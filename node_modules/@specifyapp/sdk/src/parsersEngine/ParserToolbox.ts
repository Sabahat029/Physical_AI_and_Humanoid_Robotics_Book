import type {
  ParsersEngineErrorMessage,
  ParsersEngineInformationMessage,
  ParsersEngineMessage,
  ParsersEngineWarningMessage,
} from './definitions/ParsersEngineMessage.js';
import { SpecifyError, specifyErrors } from '../errors/index.js';
import { ParserOutput } from './definitions/parserOutput.js';

export class ParserToolbox {
  output: ParserOutput | null = null;
  errorMessages: Array<ParsersEngineErrorMessage> = [];
  warningMessages: Array<ParsersEngineWarningMessage> = [];
  informationMessages: Array<ParsersEngineInformationMessage> = [];
  pipelineName = 'Default pipeline name ' + Date.now();

  constructor(options?: { pipelineName?: string }) {
    if (options?.pipelineName !== undefined) {
      this.pipelineName = options?.pipelineName;
    }
  }

  get hasError() {
    return this.errorMessages.length > 0;
  }
  get hasWarning() {
    return this.warningMessages.length > 0;
  }
  get hasInformation() {
    return this.informationMessages.length > 0;
  }

  populateMessage(message: ParsersEngineMessage) {
    switch (message.type) {
      case 'error':
        this.errorMessages.push(message);
        break;
      case 'warning':
        this.warningMessages.push(message);
        break;
      case 'information':
        this.informationMessages.push(message);
        break;
    }
  }

  populateOutput(candidateOutput: ParserOutput) {
    // First output ever
    if (this.output === null) {
      this.output = candidateOutput;
      return;
    }

    // Accumulate files
    if (this.output.type === 'files' && candidateOutput.type === 'files') {
      this.output.files.push(...candidateOutput.files);
      return;
    }

    throw new SpecifyError({
      publicMessage: `Pipeline "${this.pipelineName}" tried to populate more than one non-file type outputs. Content of type: "${this.output.type}" cannot be overwritten by content of type: "${candidateOutput.type}".`,
      errorKey: specifyErrors.PARSERS_ENGINE_HAS_TOO_MANY_OUTPUTS.errorKey,
    });
  }

  updateOutput(callback: (output: ParserOutput) => ParserOutput) {
    if (this.output === null) {
      throw new SpecifyError({
        errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OUTPUTS.errorKey,
        publicMessage: `Pipeline "${this.pipelineName}" tried to update the output but the output is not set.`,
      });
    }

    this.output = callback(this.output);
  }
}
