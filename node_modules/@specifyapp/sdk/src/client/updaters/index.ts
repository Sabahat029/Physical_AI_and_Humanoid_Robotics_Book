import { SDTFEngine, SDTFQuery } from '@specifyapp/specify-design-token-format';
import { ParserToolbox } from '../../parsersEngine/ParserToolbox.js';
import { OptionsWithoutApplyToAndRemoteExecution, UpdaterFunction } from './definitions.js';

import { changeCaseInner } from '../../builtInParsers/parsers-utility/change-case/changeCase.js';
import { ChangeCaseParserOptions } from '../../builtInParsers/parsers-utility/change-case/definition.js';
import { convertColorInner } from '../../builtInParsers/parsers-utility/convert-color/convertColor.js';
import { ConvertColorParserOptions } from '../../builtInParsers/parsers-utility/convert-color/definition.js';
import { convertDimensionInner } from '../../builtInParsers/parsers-utility/convert-dimension/convertDimension.js';
import { ConvertDimensionParserOptions } from '../../builtInParsers/parsers-utility/convert-dimension/definition.js';
import { MakeLineHeightRelativeParserOptions } from '../../builtInParsers/parsers-utility/make-line-height-relative/definition.js';
import { makeLineHeightRelativeInner } from '../../builtInParsers/parsers-utility/make-line-height-relative/makeLineHeightRelative.js';
import { PrefixByParserOptions } from '../../builtInParsers/parsers-utility/prefix-by/definition.js';
import { prefixByInner } from '../../builtInParsers/parsers-utility/prefix-by/prefixBy.js';
import { ReplaceStringParserOptions } from '../../builtInParsers/parsers-utility/replace-string/definition.js';
import { replaceStringInner } from '../../builtInParsers/parsers-utility/replace-string/replaceString.js';
import { suffixByInner } from '../../builtInParsers/parsers-utility/suffix-by/suffixBy.js';
import { RoundNumberParserOptions } from '../../builtInParsers/parsers-utility/round-number/definition.js';
import { roundNumberInner } from '../../builtInParsers/parsers-utility/round-number/roundNumber.js';

/**
 * Update all the tokens that contains a color to the given format for a given query. If the query isn't provided, then all the tokens will be updated.
 * It means that tokens such as: color, shadow, gradient, etc... Will be affected.
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(color({ toFormat: 'hex' }, { where: { token: '.*Color', select: true } }))
 * sdtf.withQuery({ where: { token: '.*Color', select: true } }).update(color({ toFormat: 'hex' }))
 */
function color(
  options: OptionsWithoutApplyToAndRemoteExecution<ConvertColorParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as ConvertColorParserOptions).applyTo = applyTo ?? applyToInner;

    convertColorInner(engine, options, new ParserToolbox({ pipelineName: 'colors' }));
  };
}

/**
 * Update all the tokens that contains a dimension to the given unit for a given query. If the query isn't provided, then all the tokens will be updated.
 * It means that tokens such as: dimension, spacing, textStyle, radii, etc... Will be affected.
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(dimension({ toFormat: 'hex', baseValue: { rem: 12 } }, { where: { token: '.*Shadow', select: true } }))
 * sdtf.withQuery({ where: { token: '.*Shadow', select: true } }).update(dimension({ toFormat: 'rem', baseValue: { rem: 16 } }))
 */
function dimension(
  options: OptionsWithoutApplyToAndRemoteExecution<ConvertDimensionParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as ConvertDimensionParserOptions).applyTo = applyTo ?? applyToInner;

    convertDimensionInner(engine, options, new ParserToolbox({ pipelineName: 'dimension' }));
  };
}

/**
 * Update all the tokens name to the given casing for a given query. If the query isn't provided, then all the tokens will be updated.
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(changeCase({ toFormat: 'camelCase' }))
 * sdtf.withQuery({ where: { token: 'snake_.*_case', select: true } }).update(changeCase({ toFormat: 'kebabCase' }))
 */
function changeCase(
  options: OptionsWithoutApplyToAndRemoteExecution<ChangeCaseParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as ChangeCaseParserOptions).applyTo = applyTo ?? applyToInner;

    changeCaseInner(engine, options, new ParserToolbox({ pipelineName: 'changeCase' }));
  };
}

/**
 * Replacing names with a given `regex` and a given `replaceBy`. You can either replace for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(replaceString({ all: {regex: 'hello', replaceBy: 'world' } }))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(replaceString({ all: {regex: 'hello', replaceBy: 'world' } }))
 */
function replaceString(
  options: OptionsWithoutApplyToAndRemoteExecution<ReplaceStringParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as ReplaceStringParserOptions).applyTo = applyTo ?? applyToInner;

    replaceStringInner(engine, options);
  };
}

/**
 * Prefixing names with a given prefix. You can either replace for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(prefixBy({ all: 'prefix-' }))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(prefixBy({ all: 'prefix-' }))
 */
function prefixBy(
  options: OptionsWithoutApplyToAndRemoteExecution<PrefixByParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as PrefixByParserOptions).applyTo = applyTo ?? applyToInner;

    prefixByInner(engine, options);
  };
}

/**
 * Suffixing names with a given suffix. You can either replace for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(suffixBy({ all: '-suffix' }))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(suffixBy({ all: '-suffix' }))
 */
function suffixBy(
  options: OptionsWithoutApplyToAndRemoteExecution<PrefixByParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as PrefixByParserOptions).applyTo = applyTo ?? applyToInner;

    suffixByInner(engine, options);
  };
}

/**
 * Convert your lineHeight from absolut to relative value. You can either convert for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(makeLineHeightRelative({}))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(makeLineHeightRelative({ basePixelValue: 24 }))
 */
function makeLineHeightRelative(
  options: OptionsWithoutApplyToAndRemoteExecution<MakeLineHeightRelativeParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as MakeLineHeightRelativeParserOptions).applyTo = applyTo ?? applyToInner;

    makeLineHeightRelativeInner(
      engine,
      options,
      new ParserToolbox({ pipelineName: 'makeLineHeightRelative' }),
    );
  };
}

/**
 * Round numbers to a given precision. You can either round for all or pick what you want.
 * This methods should be used with the `SDTFClient.update` method.
 * @example
 * sdtf.update(roundNumber({ precision: 2 }))
 * @param options
 * @param applyTo
 */
function roundNumber(
  options: OptionsWithoutApplyToAndRemoteExecution<RoundNumberParserOptions>,
  applyTo?: SDTFQuery,
): UpdaterFunction {
  return (engine: SDTFEngine, applyToInner?: SDTFQuery) => {
    (options as RoundNumberParserOptions).applyTo = applyTo ?? applyToInner;

    roundNumberInner(engine, options, new ParserToolbox({ pipelineName: 'roundNumber' }));
  };
}

export const updaters = {
  dimension,
  color,
  changeCase,
  replaceString,
  prefixBy,
  suffixBy,
  makeLineHeightRelative,
  roundNumber,
};
