import { promises as fs } from 'node:fs';
import * as nodePath from 'node:path';

/* v8 ignore start */

export function getDirectoryOfPath(path: string): string {
  return nodePath.dirname(path);
}

export function joinPath(...paths: string[]): string {
  return nodePath.join(...paths);
}

export function computeAbsolutePath(...relativePath: string[]): string {
  return nodePath.resolve(process.cwd(), ...relativePath);
}

function pathStatsOrNull(path: string) {
  return fs.stat(path).catch(() => null);
}
export async function matchIsExistingDirectory(path: string): Promise<boolean> {
  const pathStats = await pathStatsOrNull(path);
  return !!(pathStats && pathStats.isDirectory());
}
export async function matchIsExistingFile(path: string): Promise<boolean> {
  const pathStats = await pathStatsOrNull(path);
  return !!(pathStats && pathStats.isFile());
}

export function isFilePath(path: string): boolean {
  return nodePath.extname(path).length !== 0;
}

export async function generateEmptyFile(relativeFilePath: string) {
  const directoryPath = getDirectoryOfPath(relativeFilePath);
  if (!(await matchIsExistingDirectory(directoryPath))) {
    await fs.mkdir(directoryPath, {
      recursive: true,
    });
  }
  const absoluteFilePath = computeAbsolutePath(relativeFilePath);
  if (await matchIsExistingFile(absoluteFilePath)) {
    await fs.unlink(absoluteFilePath);
  }

  return absoluteFilePath;
}

/* v8 ignore stop */

export function makeFilePath(rootDirectoryPath: string, filePath: string) {
  let sanitizedRootDirectoryPath = rootDirectoryPath.trim();
  let sanitizedFilePath = filePath.trim();

  return nodePath.join(sanitizedRootDirectoryPath, sanitizedFilePath);
}
