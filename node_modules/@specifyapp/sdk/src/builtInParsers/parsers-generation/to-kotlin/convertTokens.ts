import { SpecifyDesignTokenTypeName, TokenState } from '@specifyapp/specify-design-token-format';
import { matchJsonValue } from '../../utils/jsonValueMatcher.js';
import { colorToKotlin } from './tokenTypes/color.js';
import { cubicBezierToKotlin } from './tokenTypes/cubicBezier.js';
import { dimensionToKotlin } from './tokenTypes/dimension.js';
import { durationToKotlin } from './tokenTypes/duration.js';
import { fontToKotlin } from './tokenTypes/font.js';
import { fontWeightToKotlin } from './tokenTypes/fontWeight.js';
import { opacityToKotlin } from './tokenTypes/opacity.js';
import { spacingToKotlin } from './tokenTypes/spacing.js';
import { spacingsToKotlin } from './tokenTypes/spacings.js';
import { textAlignmentHorizontalToKotlin } from './tokenTypes/textAlignHorizontal.js';
import { textStyleToKotlin } from './tokenTypes/textStyle.js';
import { transitionToKotlin } from './tokenTypes/transition.js';
import { dataOfToken, makeRenderer } from './template.js';

export type ConvertedOutput = { [type in SpecifyDesignTokenTypeName]?: { [name: string]: string } };

export type ConversionOutput = {
  variableName: string;
  value: string;
};

export type MultipleConversionOutput = Array<
  ConversionOutput & { type: SpecifyDesignTokenTypeName }
>;

export function convertTokens(
  tokens: Array<TokenState>,
  tokenNameTemplate: string,
): ConvertedOutput {
  const outputTokens = {} as ConvertedOutput;

  const renderVariable = makeRenderer(tokenNameTemplate);

  for (const token of tokens) {
    for (const mode of token.modes) {
      const variableName = renderVariable(
        dataOfToken(token, token.modes.length === 1 ? undefined : mode),
      );

      const wrapValue = (value: string | undefined) => {
        if (!value) return;

        return { variableName, value };
      };

      const output = matchJsonValue<ConversionOutput | MultipleConversionOutput>(
        {
          color: v => wrapValue(colorToKotlin(v)),
          cubicBezier: v => wrapValue(cubicBezierToKotlin(v)),
          dimension: v => wrapValue(dimensionToKotlin(v)),
          duration: v => wrapValue(durationToKotlin(v)),
          font: v => wrapValue(fontToKotlin(v)),
          fontWeight: v => wrapValue(fontWeightToKotlin(v)),
          opacity: v => wrapValue(opacityToKotlin(v)),
          spacing: v => wrapValue(spacingToKotlin(v)),
          spacings: v => wrapValue(spacingsToKotlin(v)),
          textAlignHorizontal: v => wrapValue(textAlignmentHorizontalToKotlin(v)),
          textStyle: v => wrapValue(textStyleToKotlin(v)),
          transition: v => transitionToKotlin(v, variableName),
        },
        () => {
          return undefined;
        },
        token,
        mode,
      );

      if (!output) continue;

      if (Array.isArray(output)) {
        for (const converted of output) {
          outputTokens[converted.type] ??= {};
          outputTokens[converted.type]![converted.variableName] = converted.value;
        }
      } else {
        outputTokens[token.type] ??= {};
        outputTokens[token.type]![output.variableName] = output.value;
      }
    }
  }

  return outputTokens;
}
