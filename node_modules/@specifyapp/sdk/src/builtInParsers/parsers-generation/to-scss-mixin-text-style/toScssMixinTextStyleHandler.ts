import type { DeriveBuiltInParserHandlerFromDefinition } from '../../internals/createBuiltInParserDefinition.js';
import type { ToScssMixinTextStyleParserDefinition } from './definition.js';
import { type SDTFEngine, createSDTFEngine } from '@specifyapp/specify-design-token-format';
import { merge } from 'lodash-es';
import {
  DEFAULT_TEMPLATE,
  validateTemplate,
} from '../../shared/to-scss-mixin-text-style/template.js';
import { SpecifyError, specifyErrors } from '../../../errors/index.js';
import { convertTokens } from '../../shared/to-scss-mixin-text-style/convertTokens.js';
import { convertToMixins } from './convertToMixins.js';

export const toScssMixinTextStyleHandler: DeriveBuiltInParserHandlerFromDefinition<
  ToScssMixinTextStyleParserDefinition
> = async (previousDataBox, toolbox, parserOptions, outputOptions, _context) => {
  let sdtfEngine: SDTFEngine;

  switch (previousDataBox.type) {
    case 'SDTF': {
      sdtfEngine = createSDTFEngine(previousDataBox.graph);
      break;
    }
    case 'SDTF Engine': {
      sdtfEngine = previousDataBox.engine;
      break;
    }
    default: {
      throw new SpecifyError({
        errorKey: specifyErrors.PARSERS_ENGINE_INVALID_PARSER_INPUT.errorKey,
        publicMessage: `${
          (previousDataBox as any).type
        } is not a valid input for the to-css-custom-properties parser.`,
      });
    }
  }

  if (outputOptions?.type !== 'file')
    throw new SpecifyError({
      errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OUTPUT_TYPE.errorKey,
      publicMessage: `The output type ${outputOptions?.type} is not supported by the to-tailwind parser.`,
    });

  const defaultOptions = {
    tokenNameTemplate: DEFAULT_TEMPLATE,
    exclude: [],
    include: [],
    genericFamily: '',
  };

  // Will throw if template is not valid
  if (parserOptions?.tokenNameTemplate) validateTemplate(parserOptions.tokenNameTemplate);

  const finalOptions = merge(defaultOptions, parserOptions);

  if (finalOptions.exclude.length > 0 && finalOptions.include.length > 0) {
    throw new SpecifyError({
      errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OPTION.errorKey,
      publicMessage: 'You cannot use both "exclude" and "include" options at the same time.',
    });
  }

  const { outputs, warningMessages } = convertTokens(
    sdtfEngine.query.getAllTokenStates(),
    finalOptions,
  );

  if (warningMessages.length > 0) {
    warningMessages.forEach(warningMessage => {
      toolbox.populateMessage(warningMessage);
    });
  }

  toolbox.populateOutput({
    type: 'files',
    files: [
      {
        path: outputOptions.filePath,
        content: {
          type: 'text',
          text: convertToMixins(outputs),
        },
      },
    ],
  });

  return {
    type: 'SDTF Engine',
    engine: sdtfEngine,
  };
};
