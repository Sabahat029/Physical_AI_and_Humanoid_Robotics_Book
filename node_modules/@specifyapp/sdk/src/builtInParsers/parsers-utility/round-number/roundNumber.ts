import { SpecifyError } from '../../../errors/SpecifyError.js';
import { specifyErrors } from '../../../errors/specifyErrors.js';
import { ParserToolbox } from '../../../parsersEngine/ParserToolbox.js';
import { DeriveBuiltInParserHandlerFromDefinition } from '../../internals/createBuiltInParserDefinition.js';
import { getSdtfQuery } from '../../utils/getSdtfQuery.js';
import { RoundNumberParserDefinition, RoundNumberParserOptions } from './definition.js';
import {
  createSDTFEngine,
  SDTFEngine,
  SpecifyDesignTokenTypeName,
  TokenState,
} from '@specifyapp/specify-design-token-format';
import { updateToken } from './updateToken.js';

export const AUTHORIZED_TOKENS: Array<SpecifyDesignTokenTypeName> = [
  'number',
  'zeroToOneNumber',
  'arcDegreeNumber',
  'positiveNumber',
  'percentageNumber',
  'blur',
  'border',
  'breakpoint',
  'cubicBezier',
  'dimension',
  'duration',
  'opacity',
  'radii',
  'radius',
  'shadow',
  'shadows',
  'spacing',
  'spacings',
  'textStyle',
  'transition',
];

export const roundNumberHandler: DeriveBuiltInParserHandlerFromDefinition<
  RoundNumberParserDefinition
> = async (previousDataBox, toolbox, parserOptions, _, _context) => {
  let sdtfEngine: SDTFEngine;

  switch (previousDataBox.type) {
    case 'SDTF': {
      sdtfEngine = createSDTFEngine(previousDataBox.graph, previousDataBox.metadata);
      break;
    }
    case 'SDTF Engine': {
      sdtfEngine = previousDataBox.engine;
      break;
    }
    default: {
      throw new SpecifyError({
        errorKey: specifyErrors.PARSERS_ENGINE_INVALID_PARSER_INPUT.errorKey,
        publicMessage: `${
          (previousDataBox as any).type
        } is not a valid input for the round-number parser.`,
      });
    }
  }

  roundNumberInner(sdtfEngine, parserOptions, toolbox);

  const { metadata } = sdtfEngine.exportEngineState();

  return {
    type: 'SDTF Engine',
    engine: sdtfEngine,
    metadata,
  };
};

export function roundNumberInner(
  engine: SDTFEngine,
  options: RoundNumberParserOptions,
  toolbox: ParserToolbox,
) {
  const query = getSdtfQuery(options.applyTo, {
    authorizedTokens: AUTHORIZED_TOKENS,
    tokensOnly: true,
  });

  engine.query.run(query).forEach(token => {
    if (!(token instanceof TokenState) || !token.isFullyResolvable) return;

    /* v8 ignore start */
    if (!AUTHORIZED_TOKENS.includes(token.type)) {
      // Unauthorized tokens can be targeted by a custom query
      toolbox.populateMessage({
        type: 'warning',
        content: `Tried to update token "${token.path.toString()}" of type "${token.type}" but it's not supported by round-number`,
        errorKey: specifyErrors.PARSERS_ENGINE_PARSER_EXECUTION_FAILED.errorKey,
      });
      return;
    }
    /* v8 ignore stop */

    updateToken(token, {
      precision: options.precision ?? 0,
      mode: options.mode ?? 'auto',
      applyToKeys: options.applyToKeys ?? {},
    });
  });
}
