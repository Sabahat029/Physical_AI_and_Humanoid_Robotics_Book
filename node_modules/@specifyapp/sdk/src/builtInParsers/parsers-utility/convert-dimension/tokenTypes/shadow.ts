import {
  InnerValue,
  PickSpecifyDesignToken,
  RawValueSignature,
  ResolvableValueLevelAlias,
  TokenState,
  UnresolvableModeLevelAlias,
  UnresolvableValueLevelAlias,
  ResolvedDeepStatefulValueForMode,
} from '@specifyapp/specify-design-token-format';
import type { options } from '../updateToken.js';
import { ParserToolbox } from '../../../../parsersEngine/ParserToolbox.js';
import { getDimensionUpdateValueOrUpdateAlias } from './dimension.js';
import { KeysPerToken } from '../definition.js';

export function getShadowUpdateValue(
  shadow: RawValueSignature<'shadow'>,
  options: options,
  token: TokenState<'shadow'>,
  mode: string,
  toolbox: ParserToolbox,
  allowedKeys: KeysPerToken['shadow'],
) {
  const initialValueToUpdate = token.getJSONValue({ resolveAliases: false });

  if ('$alias' in initialValueToUpdate)
    throw new Error("Unreachable as it's checked before by the statefulResult api");

  const valueToUpdate = initialValueToUpdate[mode];

  return getShadowUpdateValueFromValueToUpdate(
    shadow,
    options,
    valueToUpdate,
    toolbox,
    allowedKeys,
  );
}

export function getShadowUpdateValueFromValueToUpdate(
  shadow: RawValueSignature<'shadow'>,
  options: options,
  valueToUpdate: PickSpecifyDesignToken<'shadow', string, true, false>['$value'],
  toolbox: ParserToolbox,
  allowedKeys: KeysPerToken['shadow'],
) {
  if ('$alias' in valueToUpdate)
    throw new Error("Unreachable as it's checked before by the statefulResult api");

  if (!allowedKeys || allowedKeys.includes('offsetX')) {
    const offsetX = getDimensionUpdateValueOrUpdateAlias(shadow.offsetX, options, toolbox);
    if (!!offsetX) valueToUpdate.offsetX = offsetX;
  }

  if (!allowedKeys || allowedKeys.includes('offsetY')) {
    const offsetY = getDimensionUpdateValueOrUpdateAlias(shadow.offsetY, options, toolbox);
    if (!!offsetY) valueToUpdate.offsetY = offsetY;
  }

  if (!allowedKeys || allowedKeys.includes('spreadRadius')) {
    const spreadRadius = getDimensionUpdateValueOrUpdateAlias(
      shadow.spreadRadius,
      options,
      toolbox,
    );
    if (!!spreadRadius) valueToUpdate.spreadRadius = spreadRadius;
  }

  if (!allowedKeys || allowedKeys.includes('blurRadius')) {
    const blurRadius = getDimensionUpdateValueOrUpdateAlias(shadow.blurRadius, options, toolbox);
    if (!!blurRadius) valueToUpdate.blurRadius = blurRadius;
  }

  return valueToUpdate;
}

export function getShadowUpdateValueOrUpdateAliasFromValueToUpdate(
  shadow: InnerValue<
    ResolvableValueLevelAlias | UnresolvableValueLevelAlias | RawValueSignature<'shadow'>
  >,
  options: options,
  valueToUpdate: PickSpecifyDesignToken<'shadow', string, true, false>['$value'],
  toolbox: ParserToolbox,
  allowedKeys: KeysPerToken['shadow'],
) {
  return shadow
    .mapPrimitiveValue(v =>
      getShadowUpdateValueFromValueToUpdate(v, options, valueToUpdate, toolbox, allowedKeys),
    )
    .mapUnresolvableValueLevelAlias(_ => undefined)
    .mapResolvableValueLevelAlias(alias => {
      const { tokenState, targetMode, value } = alias.tokenState.resolveDeepStatefulValueForMode(
        alias.targetMode,
      ) as ResolvedDeepStatefulValueForMode<'shadow'>;

      if (value instanceof UnresolvableModeLevelAlias)
        throw new Error('Unreachable as token resolvability is checked before');

      const updateValue = getShadowUpdateValueFromValueToUpdate(
        value,
        options,
        valueToUpdate,
        toolbox,
        allowedKeys,
      );

      tokenState.updateModeValue(targetMode, updateValue);

      return undefined;
    })
    .unwrap();
}
