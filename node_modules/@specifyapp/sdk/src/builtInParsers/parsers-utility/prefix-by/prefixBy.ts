import { SDTFEngine, createSDTFEngine } from '@specifyapp/specify-design-token-format';
import type { PrefixByParserDefinition, PrefixByParserOptions } from './definition.js';
import { specifyErrors } from '../../../errors/specifyErrors.js';
import { getSdtfQuery } from '../../utils/getSdtfQuery.js';
import { SpecifyError } from '../../../errors/SpecifyError.js';
import { DeriveBuiltInParserHandlerFromDefinition } from '../../internals/createBuiltInParserDefinition.js';

export const prefixByHandler: DeriveBuiltInParserHandlerFromDefinition<
  PrefixByParserDefinition
> = async (previousResult, toolbox, parserOptions, _) => {
  let sdtfEngine: SDTFEngine;

  switch (previousResult.type) {
    case 'SDTF': {
      sdtfEngine = createSDTFEngine(previousResult.graph, previousResult.metadata);
      break;
    }
    case 'SDTF Engine': {
      sdtfEngine = previousResult.engine;
      break;
    }
    default: {
      throw new SpecifyError({
        errorKey: specifyErrors.PARSERS_ENGINE_INVALID_INPUT_TYPE.errorKey,
        publicMessage: `The input type ${
          (previousResult as any).type
        } is not supported by the filter parser.`,
      });
    }
  }

  if (
    !('all' in parserOptions) &&
    !parserOptions.token &&
    !parserOptions.group &&
    !parserOptions.collection
  ) {
    toolbox.populateMessage({
      type: 'warning',
      content:
        "Couldn't find a pattern in all, token, group or collection, so nothing will be prefixed",
      errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OPTION.errorKey,
    });

    return {
      type: 'SDTF Engine',
      engine: sdtfEngine,
    };
  }

  prefixByInner(sdtfEngine, parserOptions);

  return {
    type: 'SDTF Engine',
    engine: sdtfEngine,
  };
};

export function prefixByInner(engine: SDTFEngine, options: PrefixByParserOptions) {
  const query = getSdtfQuery(options.applyTo);

  (options.applyTo ? engine.query.run(query) : engine.query.getAllNodeStates()).forEach(node => {
    if ('all' in options) {
      node.rename(`${options.all}${node.name}`);
    } else if (node.isToken && options.token) {
      node.rename(`${options.token}${node.name}`);
    } else if (node.isGroup && options.group) {
      node.rename(`${options.group}${node.name}`);
    } else if (node.isCollection && options.collection) {
      node.rename(`${options.collection}${node.name}`);
    }
  });
}
