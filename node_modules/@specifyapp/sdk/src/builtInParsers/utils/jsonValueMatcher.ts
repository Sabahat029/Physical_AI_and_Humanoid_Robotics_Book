import {
  TokenState,
  PickSpecifyDesignToken,
  SpecifyDesignTokenTypeName,
} from '@specifyapp/specify-design-token-format';

export type jsonValueMatcher<T> = {
  [K in TokenState['type']]?: (
    token: PickSpecifyDesignToken<K, string, false, false>['$value'],
  ) => T | undefined;
};

/* v8 ignore start */
export function matchJsonValue<T>(
  tokenMatcher: jsonValueMatcher<T>,
  missingFn: (
    token: PickSpecifyDesignToken<SpecifyDesignTokenTypeName, string, false, false>['$value'],
  ) => T | undefined,
  token: TokenState,
  targetMode: string,
): T | undefined {
  switch (token.type) {
    case 'arcDegreeNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'arcDegreeNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'array':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'array'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'bitmap':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'bitmap'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'bitmapFormat':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'bitmapFormat'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'blur':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'blur'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'boolean':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'boolean'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'border':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'border'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'borderStyle':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'borderStyle'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'borderStyleLineCap':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'borderStyleLineCap'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'breakpoint':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'breakpoint'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'color':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'color'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'cubicBezier':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'cubicBezier'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'dimension':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'dimension'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'dimensionUnit':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'dimensionUnit'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'duration':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'duration'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'durationUnit':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'durationUnit'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'font':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'font'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'fontFamily':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'fontFamily'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'fontFeature':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'fontFeature'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'fontFeatures':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'fontFeatures'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'fontFormat':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'fontFormat'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'fontStyle':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'fontStyle'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'fontWeight':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'fontWeight'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'gradient':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'gradient'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'gradients':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'gradients'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'hexadecimalColorString':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'hexadecimalColorString'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'integerNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'integerNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'null':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'null'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'number':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'number'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'object':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'object'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'opacity':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'opacity'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'percentageNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'percentageNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'positiveIntegerNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'positiveIntegerNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'positiveNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'positiveNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'radii':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'radii'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'radius':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'radius'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'rgbColorNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'rgbColorNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'shadow':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'shadow'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'shadowType':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'shadowType'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'shadows':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'shadows'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'spacing':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'spacing'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'spacings':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'spacings'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'stepsTimingFunction':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'stepsTimingFunction'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'string':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'string'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'textAlignHorizontal':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'textAlignHorizontal'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'textAlignVertical':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'textAlignVertical'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'textDecoration':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'textDecoration'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'textStyle':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'textStyle'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'textTransform':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'textTransform'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'transition':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'transition'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'vector':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'vector'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'vectorFormat':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'vectorFormat'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'zIndex':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'zIndex'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
    case 'zeroToOneNumber':
      return (tokenMatcher[token.type] ?? missingFn)(
        (token as TokenState<'zeroToOneNumber'>).getJSONValue({
          resolveAliases: true,
          allowUnresolvable: false,
          targetMode,
        }),
      );
  }
}
/* v8 ignore stop */
