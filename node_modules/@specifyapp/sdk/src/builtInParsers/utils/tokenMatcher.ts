import { TokenState } from '@specifyapp/specify-design-token-format';

export type matcher<T> = { [K in TokenState['type']]?: (token: TokenState<K>) => T | undefined };

/* v8 ignore start */
export function matchToken<T>(
  tokenMatcher: matcher<T>,
  missingFn: (token: TokenState) => T | undefined,
  token: TokenState,
): T | undefined {
  switch (token.type) {
    case 'arcDegreeNumber':
      // @ts-ignore - Type too complex
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'arcDegreeNumber'>);
    case 'array':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'array'>);
    case 'bitmap':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'bitmap'>);
    case 'bitmapFormat':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'bitmapFormat'>);
    case 'blur':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'blur'>);
    case 'boolean':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'boolean'>);
    case 'border':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'border'>);
    case 'borderStyle':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'borderStyle'>);
    case 'borderStyleLineCap':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'borderStyleLineCap'>);
    case 'breakpoint':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'breakpoint'>);
    case 'color':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'color'>);
    case 'cubicBezier':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'cubicBezier'>);
    case 'dimension':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'dimension'>);
    case 'dimensionUnit':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'dimensionUnit'>);
    case 'duration':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'duration'>);
    case 'durationUnit':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'durationUnit'>);
    case 'font':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'font'>);
    case 'fontFamily':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'fontFamily'>);
    case 'fontFeature':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'fontFeature'>);
    case 'fontFeatures':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'fontFeatures'>);
    case 'fontFormat':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'fontFormat'>);
    case 'fontStyle':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'fontStyle'>);
    case 'fontWeight':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'fontWeight'>);
    case 'gradient':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'gradient'>);
    case 'gradients':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'gradients'>);
    case 'hexadecimalColorString':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'hexadecimalColorString'>);
    case 'integerNumber':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'integerNumber'>);
    case 'null':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'null'>);
    case 'number':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'number'>);
    case 'object':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'object'>);
    case 'opacity':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'opacity'>);
    case 'percentageNumber':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'percentageNumber'>);
    case 'positiveIntegerNumber':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'positiveIntegerNumber'>);
    case 'positiveNumber':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'positiveNumber'>);
    case 'radii':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'radii'>);
    case 'radius':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'radius'>);
    case 'rgbColorNumber':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'rgbColorNumber'>);
    case 'shadow':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'shadow'>);
    case 'shadowType':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'shadowType'>);
    case 'shadows':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'shadows'>);
    case 'spacing':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'spacing'>);
    case 'spacings':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'spacings'>);
    case 'stepsTimingFunction':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'stepsTimingFunction'>);
    case 'string':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'string'>);
    case 'textAlignHorizontal':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'textAlignHorizontal'>);
    case 'textAlignVertical':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'textAlignVertical'>);
    case 'textDecoration':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'textDecoration'>);
    case 'textStyle':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'textStyle'>);
    case 'textTransform':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'textTransform'>);
    case 'transition':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'transition'>);
    case 'vector':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'vector'>);
    case 'vectorFormat':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'vectorFormat'>);
    case 'zIndex':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'zIndex'>);
    case 'zeroToOneNumber':
      return (tokenMatcher[token.type] ?? missingFn)(token as TokenState<'zeroToOneNumber'>);
  }
}
/* v8 ignore stop */
