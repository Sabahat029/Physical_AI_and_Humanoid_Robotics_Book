import { SDKTelemetry } from '../../telemetry/provider.js';
import { SpecifyError, specifyErrors } from '../../errors/index.js';
import { ParserToolbox } from '../ParserToolbox.js';
import { makeRemoteParsersPipelinesFromRules } from './makeRemoteParsersPipelinesFromRules.js';
import { makeLocalBuiltInParsersPipelineFromRule } from './makeLocalBuiltInParsersPipelineFromRule.js';
import { validateRuleOrBuildErrorParserFunction } from './validateRuleOrBuildErrorParserFunction.js';
function matchRemotelyExecutedRule(candidate) {
    return (candidate &&
        typeof candidate === 'object' &&
        !Array.isArray(candidate) &&
        'shouldExecuteRemotely' in candidate &&
        candidate.shouldExecuteRemotely === true);
}
/**
 * Build many pipelines resolved by a single HTTP request
 * @param maybeRules
 * @param context
 */
export function createPipelineStatesFromRules(maybeRules, context) {
    const telemetry = new SDKTelemetry();
    for (const rule of maybeRules) {
        // Validate the shallow structure of the rule
        if (typeof rule !== 'object' || rule === null || Array.isArray(rule)) {
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_VALIDATION_ERROR.errorKey,
                publicMessage: 'Invalid rule argument. Must be a Rule configuration object.',
            });
        }
        // Track the initialization of the built-in parser
        try {
            const castedRule = rule;
            if ('parsers' in castedRule) {
                for (const parser of castedRule.parsers) {
                    telemetry.track('Built In Parser Initialized', {
                        isFromRule: true,
                        parserName: parser.name,
                        options: parser.options ?? {},
                        output: parser.output ?? {},
                    });
                }
            }
        }
        catch (error) { }
    }
    // Segregate the rules for remote and local execution
    const { rulesToExecuteRemotely, rulesToExecuteLocally } = maybeRules.reduce((acc, rule, 
    // We need to keep the order of the rules before segregation
    _sortingIndex) => {
        // Remote environment always executes locally
        if (context.isRemote) {
            acc.rulesToExecuteLocally.push({ _sortingIndex, ...rule });
            return acc;
        }
        if (matchRemotelyExecutedRule(rule)) {
            acc.rulesToExecuteRemotely.push({ _sortingIndex, ...rule });
        }
        else {
            acc.rulesToExecuteLocally.push({ _sortingIndex, ...rule });
        }
        return acc;
    }, {
        rulesToExecuteRemotely: [],
        rulesToExecuteLocally: [],
    });
    // Turn remote rules into pipelines wrapping the RPC calls
    const remotePipelineStates = makeRemoteParsersPipelinesFromRules(rulesToExecuteRemotely.map(({ _sortingIndex, ...rule }) => rule), {
        personalAccessToken: context.personalAccessToken,
    }).map((parserFunction, index) => {
        const localRuleWithIndex = rulesToExecuteRemotely[index];
        /* v8 ignore next 5 */
        if (!localRuleWithIndex)
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_UNKNOWN_ERROR.errorKey,
                publicMessage: 'Design Error :: Rule must exists.',
            });
        const { _sortingIndex, ...rule } = localRuleWithIndex;
        const result = validateRuleOrBuildErrorParserFunction(rule, [rule.name ?? _sortingIndex], context);
        return {
            _sortingIndex: localRuleWithIndex._sortingIndex,
            state: {
                // We override the function with the one that will throw the validation errors
                fn: result.isValid ? parserFunction : result.parserFunctionWithError,
                toolbox: new ParserToolbox({
                    pipelineName: localRuleWithIndex.name
                        ? `#${localRuleWithIndex._sortingIndex} [remote] Rule: ${localRuleWithIndex.name}`
                        : `#${localRuleWithIndex._sortingIndex} [remote] Rule`,
                }),
                isFromRule: true,
                isRemotelyExecutedRule: true,
                status: 'pending',
                next: undefined,
            },
        };
    });
    // Turn local rules into pipelines
    const localPipelineStates = rulesToExecuteLocally.map(({ _sortingIndex, ...rule }) => {
        const result = validateRuleOrBuildErrorParserFunction(rule, [rule.name ?? _sortingIndex], context);
        return {
            _sortingIndex: _sortingIndex,
            state: {
                fn: result.isValid
                    ? // We override the function with the one that will throw the validation errors
                        makeLocalBuiltInParsersPipelineFromRule(result.rule, {
                            isRemote: context.isRemote,
                            personalAccessToken: context.personalAccessToken,
                        })
                    : result.parserFunctionWithError,
                toolbox: new ParserToolbox({
                    pipelineName: rule?.name
                        ? `#${_sortingIndex} Rule: ${rule?.name}`
                        : `#${_sortingIndex} Rule`,
                }),
                isFromRule: true,
                isRemotelyExecutedRule: false,
                status: 'pending',
                next: undefined,
            },
        };
    });
    return ([...remotePipelineStates, ...localPipelineStates]
        // We sort the states by their initial indexes to keep the order of the rules
        .sort((a, b) => a._sortingIndex - b._sortingIndex)
        .map(({ state }) => state));
}
//# sourceMappingURL=createPipelineStatesFromRules.js.map