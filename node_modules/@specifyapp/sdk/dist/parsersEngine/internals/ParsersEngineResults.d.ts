import { FilesOutput, ParserOutput } from '../definitions/parserOutput.js';
import type { ParsersEngineDataBox } from '../definitions/parsersEngineDataBox.js';
import type { ParsersEngineErrorMessage, ParsersEngineInformationMessage, ParsersEngineWarningMessage } from '../definitions/ParsersEngineMessage.js';
import { SerializedParsersEngineResults } from './SerializedParsersEngineResult.js';
export type ParsersEngineResult = {
    pipelineName: string;
    isFromRule: boolean;
    status: 'success' | 'error';
    output: ParserOutput | null;
    next: ParsersEngineDataBox | undefined;
    errorMessages: Array<ParsersEngineErrorMessage>;
    warningMessages: Array<ParsersEngineWarningMessage>;
    informationMessages: Array<ParsersEngineInformationMessage>;
};
export declare class ParsersEngineResults<R extends Array<ParsersEngineResult>> {
    #private;
    constructor(results: R);
    /**
     * Get the raw results of the parser pipelines execution
     */
    get all(): R;
    /**
     * Whether any of the pipelines returned an error
     */
    get hasError(): boolean;
    /**
     * Whether any of the pipelines returned warnings
     */
    get hasWarning(): boolean;
    /**
     * Gather the error messages from all the pipelines
     */
    get allErrorMessages(): ParsersEngineErrorMessage[];
    /**
     * Gather the warning messages from all the pipelines
     */
    get allWarningMessages(): ParsersEngineWarningMessage[];
    /**
     * Gather the information messages from all the pipelines
     */
    get allInformationMessages(): ParsersEngineInformationMessage[];
    /**
     * Print error messages to the console
     */
    logErrorMessages(): void;
    /**
     * Print warning messages to the console
     */
    logWarningMessages(): void;
    /**
     * Print information messages to the console
     */
    logInformationMessages(): void;
    /**
     * Print a summary of the execution results to the console
     * @param withOutputContent - print the content of the produced output(s)
     * @param withNextContent - print the content of the next data box
     */
    debug({ withOutputContent, withNextContent, }?: {
        withOutputContent?: boolean;
        withNextContent?: boolean;
    }): void;
    /**
     * Map over any output of the parsers. This method is quite convenient if you want to run some post-process on the output.
     * @param fn
     */
    mapOutput(fn: (output: ParserOutput | null) => ParserOutput | null | void): this;
    /**
     * Map over output files. This method is quite convenient if you want to run some post-process on the files
     * @param {(file: { path: string; content: { type: "text"; text: string; } | { type: "url"; url: string; }}) => { path: string; content: { type: "text"; text: string; } | { type: "url"; url: string; }}} fn - The mapping function
     */
    mapFiles(fn: (file: FilesOutput['files'][number]) => FilesOutput['files'][number] | void): this;
    /**
     * Write the outputs of the parsers to the file system
     * @param [directoryPath] - Root directory where all the files will be written
     */
    writeToDisk(directoryPath?: string): Promise<{
        errors: Array<any>;
        outputPaths: Array<string>;
    }>;
    /**
     * Serialize the results before HTTP transmission
     */
    serialize(): SerializedParsersEngineResults;
}
//# sourceMappingURL=ParsersEngineResults.d.ts.map