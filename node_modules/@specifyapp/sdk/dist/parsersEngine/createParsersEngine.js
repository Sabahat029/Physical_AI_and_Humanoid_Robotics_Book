import { createPipelineStatesFromRules } from './internals/createPipelineStatesFromRules.js';
import { makeExecuteParsersEngine, } from './internals/makeExecuteParsersEngine.js';
import { SpecifyError, specifyErrors } from '../errors/index.js';
import { createPipelineStatesFromParserFunctions } from './internals/createPipelineStatesFromParserFunctions.js';
/**
 * Create a parsers engine from an array of pipelines or parser rules
 * @param pipelines
 * @param data
 * @param context
 */
export function createParsersEngine(pipelines, data, context) {
    if (!Array.isArray(pipelines)) {
        throw new SpecifyError({
            errorKey: specifyErrors.PARSERS_ENGINE_VALIDATION_ERROR.errorKey,
            publicMessage: 'Invalid pipelines argument. Must be an array of Parser functions and/or Parser configuration rules.',
        });
    }
    // Segregate the pipelines to be created from parserFunctions and parserRules
    const { functions, rules } = pipelines.reduce((acc, input, i) => {
        if (typeof input === 'function') {
            acc.functions.push(input);
        }
        else if (input !== null && typeof input === 'object' && !Array.isArray(input)) {
            acc.rules.push(input);
        }
        else {
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_VALIDATION_ERROR.errorKey,
                publicMessage: 'Invalid pipeline argument. Must be a Parser function or a Rule configuration object.',
            });
        }
        return acc;
    }, { functions: [], rules: [] });
    const pipelineStates = [
        ...createPipelineStatesFromParserFunctions(functions),
        ...createPipelineStatesFromRules(rules, {
            isRemote: context?.isRemote ?? false,
            builtInParserKind: context?.builtInParserKind ?? 'all',
            personalAccessToken: context?.personalAccessToken,
        }),
    ];
    const executionContext = {
        isRemote: context?.isRemote ?? false,
        resolveRepositoryTokenTree: context?.resolveRepositoryTokenTree ??
            (() => Promise.reject(new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_RESOLVE_REPOSITORY_FAILED.errorKey,
                publicMessage: '`resolveRepositoryTokenTree` method is not implemented.',
            }))),
    };
    return makeExecuteParsersEngine(pipelineStates, executionContext, data);
}
//# sourceMappingURL=createParsersEngine.js.map