import { SpecifyError, specifyErrors } from '../errors/index.js';
/**
 * Creates a pipeline of Parser functions that will be sequentially executed SDTF -> A -> B -> C...
 * Each Parser function must implement the ParserFunction signature: (data: ParsersEngineDataBox, toolbox: ParserToolbox) => Promise<ParsersEngineDataBox>
 * @example
 * const pipeline = chainParserFunctions(
 *   parsers.svgo(),
 *   parsers.svgToJsx({ output: { type: ... } }),
 *   async (dataBox, toolbox) => {
 *     // custom code
 *     return dataBox;
 *   }
 * );
 * @param parserFunctions
 */
export function chainParserFunctions(...parserFunctions) {
    if (!parserFunctions || parserFunctions.length === 0) {
        throw new SpecifyError({
            errorKey: specifyErrors.PARSERS_ENGINE_PARSER_EXECUTION_FAILED.errorKey,
            publicMessage: `No parsers provided to chainParserFunctions.`,
        });
    }
    // We use a named function to allow execution/debug to capture the function name
    async function executeParsersPipeline(dataBox, toolbox) {
        let result = dataBox;
        for (const parser of parserFunctions) {
            result = await parser(result, toolbox);
        }
        return result;
    }
    return executeParsersPipeline;
}
//# sourceMappingURL=chainParserFunctions.js.map