import { SpecifyError, specifyErrors } from '../errors/index.js';
export const SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME = 'Authorization';
export function makePersonalAccessTokenHeaderValue(personalAccessToken) {
    if (typeof personalAccessToken !== 'string' || personalAccessToken.length === 0) {
        throw new SpecifyError({
            publicMessage: 'Personal access token must be a string',
            errorKey: specifyErrors.UNEXPECTED_ERROR.errorKey,
        });
    }
    return `PAT ${personalAccessToken}`;
}
export function generatePersonalAccessTokenHeader(personalAccessToken) {
    if (!personalAccessToken)
        return {};
    return {
        [SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME]: makePersonalAccessTokenHeaderValue(personalAccessToken),
    };
}
export function extractPersonalAccessTokenFromHeaderValue(headerValue) {
    if (headerValue.startsWith('PAT ')) {
        return headerValue.slice(4);
    }
}
const lowercase_SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME = SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME.toLowerCase();
export function extractPersonalAccessTokenFromHeaders(headers) {
    const assertedHeaders = headers ?? {};
    let authorizationHeader;
    if (assertedHeaders.hasOwnProperty(lowercase_SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME)) {
        authorizationHeader = assertedHeaders[lowercase_SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME];
    }
    else if (assertedHeaders.hasOwnProperty(SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME)) {
        authorizationHeader = assertedHeaders[SPECIFY_HTTP_API_AUTHORIZATION_HEADER_NAME];
    }
    if (authorizationHeader) {
        if (Array.isArray(authorizationHeader)) {
            return extractPersonalAccessTokenFromHeaderValue(authorizationHeader[0]);
        }
        return extractPersonalAccessTokenFromHeaderValue(authorizationHeader);
    }
}
//# sourceMappingURL=authentication.js.map