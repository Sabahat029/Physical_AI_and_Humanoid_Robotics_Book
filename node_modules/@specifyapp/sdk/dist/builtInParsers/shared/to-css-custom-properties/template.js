import { sanitizeName } from './sanitizeName.js';
import { ResolvableTopLevelAlias, } from '@specifyapp/specify-design-token-format';
import { ALIAS_SEPARATOR } from './constants.js';
import { DEFAULT_MODE } from '../../utils/constants.js';
import { parseMustacheTemplate } from '../../utils/parseMustacheTemplate.js';
import { SpecifyError, specifyErrors } from '../../../errors/index.js';
var Variable;
(function (Variable) {
    Variable["COLLECTION"] = "collection";
    Variable["MODE"] = "mode";
    Variable["GROUPS"] = "groups";
    Variable["TOKEN"] = "token";
})(Variable || (Variable = {}));
const GROUPLESS_TOKEN_NOT_IN_COLLECTION_TEMPLATE = '--{{token}}-{{mode}}';
export const DEFAULT_TOKEN_NOT_IN_COLLECTION_TEMPLATE = '--{{groups}}-{{token}}-{{mode}}';
const GROUPLESS_TOKEN_TEMPLATE = '--{{token}}';
export const DEFAULT_SELECTOR_TEMPLATE = ':root[data-{{collection}}="{{mode}}"]';
export const DEFAULT_TOKEN_TEMPLATE = '--{{groups}}-{{token}}';
const templateMatch = {
    [DEFAULT_TOKEN_NOT_IN_COLLECTION_TEMPLATE]: {
        // hasGroup:hasMode
        ['true:true']: DEFAULT_TOKEN_NOT_IN_COLLECTION_TEMPLATE,
        ['false:true']: GROUPLESS_TOKEN_NOT_IN_COLLECTION_TEMPLATE,
        ['true:false']: DEFAULT_TOKEN_TEMPLATE,
        ['false:false']: GROUPLESS_TOKEN_TEMPLATE,
    },
    // hasGroup
    [DEFAULT_TOKEN_TEMPLATE]: {
        ['true']: DEFAULT_TOKEN_TEMPLATE,
        ['false']: GROUPLESS_TOKEN_TEMPLATE,
    },
};
export const validateSelectorTemplate = (template) => parseMustacheTemplate(template).forEach(variable => {
    if (variable === Variable.GROUPS || variable === Variable.TOKEN)
        throw new SpecifyError({
            errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OPTION.errorKey,
            publicMessage: `'${variable}' is not a valid variable for the 'selectorTemplate' option.`,
        });
});
export const dataOfResolvedStatefulAlias = (resolved, mode) => dataOfToken(resolved.tokenState, resolved instanceof ResolvableTopLevelAlias ? mode : resolved.targetMode);
export const dataOfToken = (token, mode) => {
    const collection = token.getCollection()?.name ?? undefined;
    const groups = (() => {
        if (token.path.length < 2)
            return undefined;
        if (token.path.at(0) === collection && token.path.at(1) === token.name)
            return undefined;
        else if (token.path.at(0) === collection) {
            return token.path.toArray().slice(1, token.path.length - 1);
        }
        else
            return token.path.toArray().slice(0, token.path.length - 1);
    })()?.join(ALIAS_SEPARATOR);
    return {
        collection,
        groups,
        mode,
        token: token.name,
    };
};
export const renderTemplate = (template, data, toolbox) => {
    const variables = parseMustacheTemplate(template);
    // We want to remove the 'default' mode for tokens not in collections
    let rendered = template === DEFAULT_TOKEN_NOT_IN_COLLECTION_TEMPLATE
        ? templateMatch[template][`${!!data.groups}:${!!data.mode && data.mode !== DEFAULT_MODE}`]
        : template === DEFAULT_TOKEN_TEMPLATE
            ? templateMatch[template][`${!!data.groups}`]
            : template;
    for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];
        if (!data[variable]) {
            toolbox.populateMessage({
                type: 'warning',
                content: `Undefined template variable '${variable}'`,
                errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OPTION.errorKey,
            });
        }
        const regexp = new RegExp(`{{${variable}}}`, 'g');
        rendered = rendered.replace(regexp, sanitizeName(data[variable] ?? ''));
    }
    return rendered;
};
export const makeRenderer = (template, parserOptions, toolbox, isSelectorTemplate = false) => (data) => {
    // Enforcing the collectionless template because when rendering the alias of a token
    // We're using the same renderer for simplicity, but depending on token state, collection might be present or not
    // So rather than creating a renderer for each token, I prefer update it on the fly
    const finalTemplate = !data.collection
        ? parserOptions.tokenNotInCollectionNameTemplate ?? DEFAULT_TOKEN_NOT_IN_COLLECTION_TEMPLATE
        : isSelectorTemplate
            ? template
            : parserOptions.tokenNameTemplate ?? DEFAULT_TOKEN_TEMPLATE;
    return renderTemplate(finalTemplate, data, toolbox);
};
//# sourceMappingURL=template.js.map