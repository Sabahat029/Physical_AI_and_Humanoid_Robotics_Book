import { createSDTFEngine, isSDTFEngine, } from '@specifyapp/specify-design-token-format';
import { specifyErrors } from '../../../errors/index.js';
import { retrieveSVGContentFromUrl } from './retrieveSVGContentFromUrl.js';
function generateVectorDataBox(tokensOrEngine, toolbox) {
    const sdtfEngine = isSDTFEngine(tokensOrEngine)
        ? tokensOrEngine
        : createSDTFEngine(tokensOrEngine);
    // @ts-ignore -  Expression produces a union type that is too complex to represent.
    const tokenStates = sdtfEngine.query.run({
        where: {
            token: '.*',
            withTypes: {
                include: ['vector', 'vectors'],
            },
            select: true,
        },
    });
    /* v8 ignore start */
    const populateWarningMessageCallback = (svgVector) => {
        toolbox.populateMessage({
            type: 'warning',
            content: `The SVG vector ${svgVector.name} is not resolvable.`,
            errorKey: specifyErrors.PARSERS_ENGINE_PARSER_EXECUTION_FAILED.errorKey,
        });
        return null;
    };
    /* c8 ignore stop */
    return {
        type: 'vector',
        assets: tokenStates.flatMap(tokenState => {
            if (!tokenState.isFullyResolvable) {
                populateWarningMessageCallback(tokenState);
                return [];
            }
            const tokensByMode = tokenState.matchJSONValueByType({
                vector: v => [v],
                vectors: v => v.files,
            }, _ => undefined);
            if (!tokensByMode)
                return [];
            return Object.entries(tokensByMode).flatMap(([mode, tokens]) => tokens.map(token => ({
                path: tokenState.path.toArray().slice(0),
                mode,
                url: token.url,
                provider: token.provider,
                format: token.format,
                token: tokenState.getJSONToken(),
            })));
        }, []),
    };
}
export async function pullSvgContent(asset, toolbox) {
    if (asset.vector)
        return asset;
    if (asset.format === 'pdf') {
        toolbox.populateMessage({
            type: 'warning',
            content: `The token at path "${asset.path.join('.')}" is a PDF, and for now they are not retrieved`,
            errorKey: specifyErrors.PARSERS_ENGINE_PARTIAL_OUTPUT.errorKey,
        });
        return asset;
    }
    const rawSvg = await retrieveSVGContentFromUrl(asset.url);
    if (!rawSvg) {
        toolbox.populateMessage({
            type: 'warning',
            content: `The SVG file at ${asset.url} could not be retrieved. It will be skipped.`,
            errorKey: specifyErrors.PARSERS_ENGINE_PARTIAL_OUTPUT.errorKey,
        });
        return asset;
    }
    asset.vector = rawSvg;
    return asset;
}
export async function pullSvgContentInVectorDataBox(vectorDataBox, toolbox) {
    vectorDataBox.assets = await Promise.all(vectorDataBox.assets.map(v => pullSvgContent(v, toolbox)));
    return vectorDataBox;
}
export async function generateVectorDataBoxAndPullSvgsContent(tokensOrEngine, toolbox) {
    return pullSvgContentInVectorDataBox(generateVectorDataBox(tokensOrEngine, toolbox), toolbox);
}
//# sourceMappingURL=generateVectorDataBoxFiles.js.map