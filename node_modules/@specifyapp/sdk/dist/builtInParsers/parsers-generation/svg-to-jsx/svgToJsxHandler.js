import { SpecifyError, specifyErrors } from '../../../errors/index.js';
import { generateDefaultJSXTemplate } from './utils/generateDefaultJSXTemplate.js';
import { pullSvgContent, generateVectorDataBoxAndPullSvgsContent, } from '../../shared/to-svg-file/generateVectorDataBoxFiles.js';
import { validateTemplate } from '../../shared/to-scss-mixin-text-style/template.js';
const DEFAULT_TEMPLATE = '{{token}}';
export const svgToJsxHandler = async (previousDataBox, toolbox, parserOptions, outputOptions, _context) => {
    let vectorAssets;
    switch (previousDataBox.type) {
        case 'vector': {
            vectorAssets = await Promise.all(previousDataBox.assets.map(v => pullSvgContent(v, toolbox)));
            break;
        }
        case 'SDTF': {
            vectorAssets = (await generateVectorDataBoxAndPullSvgsContent(previousDataBox.graph, toolbox))
                .assets;
            break;
        }
        case 'SDTF Engine': {
            vectorAssets = (await generateVectorDataBoxAndPullSvgsContent(previousDataBox.engine, toolbox)).assets;
            break;
        }
        default:
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_INVALID_PARSER_INPUT.errorKey,
                publicMessage: `${previousDataBox.type} is not a valid input for the svg-to-jsx parser.`,
            });
    }
    if (parserOptions?.tokenNameTemplate) {
        validateTemplate(parserOptions.tokenNameTemplate);
    }
    const tokenNameTemplate = parserOptions?.tokenNameTemplate ?? DEFAULT_TEMPLATE;
    if (outputOptions?.type !== 'directory') {
        throw new SpecifyError({
            errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OUTPUT_TYPE.errorKey,
            publicMessage: `The output type ${outputOptions?.type} is not supported by the svg-to-jsx parser.`,
        });
    }
    const { reactVersion, filePrefix, fileSuffix } = parserOptions ?? {};
    const isTsx = parserOptions?.tsx ?? false;
    toolbox.populateOutput({
        type: 'files',
        files: vectorAssets
            .map(asset => {
            const hasMoreThan1Mode = Object.keys(asset.token.$value).length > 1;
            if (!asset.vector) {
                throw new SpecifyError({
                    errorKey: specifyErrors.PARSERS_ENGINE_PARSER_EXECUTION_FAILED.errorKey,
                    publicMessage: `The content of the vector "${asset.path.join('.')}" is supposed to be retrieved before`,
                });
            }
            const svg = generateDefaultJSXTemplate(asset.vector, { path: asset.path, mode: asset.mode }, {
                reactVersion,
                filePrefix,
                fileSuffix,
                isExportDefault: parserOptions?.exportDefault ?? true,
                tokenNameTemplate,
            });
            return {
                path: `${outputOptions.directoryPath}/${asset.path.join('/')}${hasMoreThan1Mode ? `-${asset.mode}` : ''}.${isTsx ? 'tsx' : 'jsx'}`,
                content: {
                    type: 'text',
                    text: svg,
                },
            };
        })
            .flat(2),
    });
    return {
        type: 'vector',
        assets: vectorAssets,
    };
};
//# sourceMappingURL=svgToJsxHandler.js.map