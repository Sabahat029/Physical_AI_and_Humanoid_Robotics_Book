import { SpecifyError, specifyErrors } from '../../../errors/index.js';
import { capitalize, lowerFirst, upperFirst } from 'lodash-es';
function sanitizeName(name) {
    return name.replace(/[\/\| \\~,@#%^&*(){}|[\]?<>"'+=!-]/g, '_');
}
var Variable;
(function (Variable) {
    Variable["MODE"] = "mode";
    Variable["PATH"] = "path";
    Variable["TOKEN"] = "token";
})(Variable || (Variable = {}));
export const DEFAULT_TEMPLATE = '{{path}}{{token}}{{mode}}';
const parse = (template) => (template.match(/{{(.*?)}}/g) ?? []).map(v => v.replace(/{|}/g, ''));
export const validateTemplate = (template) => parse(template).forEach(variable => {
    if (![Variable.PATH, Variable.MODE, Variable.TOKEN].includes(variable))
        throw new SpecifyError({
            errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OPTION.errorKey,
            publicMessage: `'${variable}' is not a valid variable for the 'template' option.`,
        });
});
export const dataOfToken = (token, mode) => {
    const path = token.path
        .toArray()
        .slice(0, token.path.length - 1)
        .map((v, i) => (i === 0 ? v.toLowerCase() : capitalize(v)));
    return {
        path,
        mode,
        token: token.name,
    };
};
export const renderTemplate = (template, data) => {
    const variables = parse(template);
    let rendered = template;
    let isFirstApplied = true;
    for (let i = 0; i < variables.length; ++i) {
        const variable = variables[i];
        const regexp = new RegExp(`{{${variable}}}`);
        const currentName = data[variable];
        let name;
        let isPath = false;
        if (i === 0 && Array.isArray(currentName) && currentName.length > 0) {
            name = lowerFirst(currentName.join(''));
            isPath = true;
        }
        else if (Array.isArray(currentName)) {
            name = upperFirst(currentName.join(''));
            isPath = true;
        }
        else if (i === 0) {
            name = currentName?.toLowerCase();
        }
        else {
            name = capitalize(currentName);
        }
        const sanitized = sanitizeName(name ?? '');
        rendered = rendered.replace(regexp, isFirstApplied && !isPath ? sanitized.toLowerCase() : sanitized);
        if (name !== '') {
            isFirstApplied = false;
        }
    }
    return rendered;
};
export const makeRenderer = (template) => (data) => {
    return renderTemplate(template, data);
};
//# sourceMappingURL=template.js.map