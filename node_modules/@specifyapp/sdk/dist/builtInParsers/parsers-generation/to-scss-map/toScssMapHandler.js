import { createSDTFEngine } from '@specifyapp/specify-design-token-format';
import { SpecifyError, specifyErrors } from '../../../errors/index.js';
import { DEFAULT_TEMPLATE, validateTemplate, } from '../../shared/to-scss-mixin-text-style/template.js';
import { merge } from 'lodash-es';
import { convertTokens } from './convertTokens.js';
export const toScssMapHandler = async (previousDataBox, toolbox, parserOptions, outputOptions, _context) => {
    let sdtfEngine;
    switch (previousDataBox.type) {
        case 'SDTF': {
            sdtfEngine = createSDTFEngine(previousDataBox.graph);
            break;
        }
        case 'SDTF Engine': {
            sdtfEngine = previousDataBox.engine;
            break;
        }
        default: {
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_INVALID_PARSER_INPUT.errorKey,
                publicMessage: `${previousDataBox.type} is not a valid input for the to-css-custom-properties parser.`,
            });
        }
    }
    if (outputOptions?.type !== 'directory')
        throw new SpecifyError({
            errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OUTPUT_TYPE.errorKey,
            publicMessage: `The output type ${outputOptions?.type} is not supported by the to-tailwind parser.`,
        });
    const defaultOptions = {
        tokenNameTemplate: DEFAULT_TEMPLATE,
    };
    // Will throw if template is not valid
    if (parserOptions?.tokenNameTemplate)
        validateTemplate(parserOptions.tokenNameTemplate);
    const finalOptions = merge(defaultOptions, parserOptions);
    toolbox.populateOutput({
        type: 'files',
        files: convertTokens(sdtfEngine, outputOptions.directoryPath, finalOptions),
    });
    return {
        type: 'SDTF Engine',
        engine: sdtfEngine,
    };
};
//# sourceMappingURL=toScssMapHandler.js.map