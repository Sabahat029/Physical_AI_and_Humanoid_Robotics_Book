const nativeEsmExtensionsMapping = {
    js: 'js',
    jsx: 'js',
    ts: 'js',
    tsx: 'js',
};
function getMappedExtension(extension, useFileExtensionsInImport, extensionMapping) {
    if (!useFileExtensionsInImport) {
        return '';
    }
    return extensionMapping[extension] ?? extension;
}
export function renderBarrelFile(files, { useSemicolon = true, useFileExtensionsInImport = false, quoteCharacter = '"', removePatternInOutputFilePath = '', matchOutputFilePathPattern = '.(js|jsx|ts|tsx)$', fileExtensionsMapping = nativeEsmExtensionsMapping, }) {
    const entries = files
        .filter(file => new RegExp(matchOutputFilePathPattern, 'g').test(file.path))
        .map(file => {
        const fileExtension = file.path.split('.').pop() ?? '';
        const fullExtensionLength = fileExtension ? fileExtension.length + 1 : 0; // +1 for the dot character
        const extensionLessPath = file.path.slice(0, -fullExtensionLength);
        const mappedExtension = getMappedExtension(fileExtension, useFileExtensionsInImport, fileExtensionsMapping);
        const path = mappedExtension.length > 0 ? `${extensionLessPath}.${mappedExtension}` : extensionLessPath;
        const withMask = removePatternInOutputFilePath
            ? path.replace(removePatternInOutputFilePath, '')
            : path;
        const pathWithPrefix = withMask.startsWith('./') || withMask.startsWith('/') ? withMask : `./${withMask}`;
        return `export * from ${quoteCharacter}${pathWithPrefix}${quoteCharacter}${useSemicolon ? ';' : ''}`;
    });
    return entries.length > 0 ? entries.join('\n') + '\n' : `export {}${useSemicolon ? ';' : ''}\n`;
}
//# sourceMappingURL=renderBarrelFile.js.map