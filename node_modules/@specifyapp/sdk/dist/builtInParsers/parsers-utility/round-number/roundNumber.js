import { SpecifyError } from '../../../errors/SpecifyError.js';
import { specifyErrors } from '../../../errors/specifyErrors.js';
import { getSdtfQuery } from '../../utils/getSdtfQuery.js';
import { createSDTFEngine, TokenState, } from '@specifyapp/specify-design-token-format';
import { updateToken } from './updateToken.js';
export const AUTHORIZED_TOKENS = [
    'number',
    'zeroToOneNumber',
    'arcDegreeNumber',
    'positiveNumber',
    'percentageNumber',
    'blur',
    'border',
    'breakpoint',
    'cubicBezier',
    'dimension',
    'duration',
    'opacity',
    'radii',
    'radius',
    'shadow',
    'shadows',
    'spacing',
    'spacings',
    'textStyle',
    'transition',
];
export const roundNumberHandler = async (previousDataBox, toolbox, parserOptions, _, _context) => {
    let sdtfEngine;
    switch (previousDataBox.type) {
        case 'SDTF': {
            sdtfEngine = createSDTFEngine(previousDataBox.graph, previousDataBox.metadata);
            break;
        }
        case 'SDTF Engine': {
            sdtfEngine = previousDataBox.engine;
            break;
        }
        default: {
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_INVALID_PARSER_INPUT.errorKey,
                publicMessage: `${previousDataBox.type} is not a valid input for the round-number parser.`,
            });
        }
    }
    roundNumberInner(sdtfEngine, parserOptions, toolbox);
    const { metadata } = sdtfEngine.exportEngineState();
    return {
        type: 'SDTF Engine',
        engine: sdtfEngine,
        metadata,
    };
};
export function roundNumberInner(engine, options, toolbox) {
    const query = getSdtfQuery(options.applyTo, {
        authorizedTokens: AUTHORIZED_TOKENS,
        tokensOnly: true,
    });
    engine.query.run(query).forEach(token => {
        if (!(token instanceof TokenState) || !token.isFullyResolvable)
            return;
        /* v8 ignore start */
        if (!AUTHORIZED_TOKENS.includes(token.type)) {
            // Unauthorized tokens can be targeted by a custom query
            toolbox.populateMessage({
                type: 'warning',
                content: `Tried to update token "${token.path.toString()}" of type "${token.type}" but it's not supported by round-number`,
                errorKey: specifyErrors.PARSERS_ENGINE_PARSER_EXECUTION_FAILED.errorKey,
            });
            return;
        }
        /* v8 ignore stop */
        updateToken(token, {
            precision: options.precision ?? 0,
            mode: options.mode ?? 'auto',
            applyToKeys: options.applyToKeys ?? {},
        });
    });
}
//# sourceMappingURL=roundNumber.js.map