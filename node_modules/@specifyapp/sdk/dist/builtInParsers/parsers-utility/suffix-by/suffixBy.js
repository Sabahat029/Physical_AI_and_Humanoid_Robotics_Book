import { createSDTFEngine } from '@specifyapp/specify-design-token-format';
import { specifyErrors } from '../../../errors/specifyErrors.js';
import { getSdtfQuery } from '../../utils/getSdtfQuery.js';
import { SpecifyError } from '../../../errors/SpecifyError.js';
export const suffixByHandler = async (previousResult, toolbox, parserOptions, _) => {
    let sdtfEngine;
    switch (previousResult.type) {
        case 'SDTF': {
            sdtfEngine = createSDTFEngine(previousResult.graph, previousResult.metadata);
            break;
        }
        case 'SDTF Engine': {
            sdtfEngine = previousResult.engine;
            break;
        }
        default: {
            throw new SpecifyError({
                errorKey: specifyErrors.PARSERS_ENGINE_INVALID_INPUT_TYPE.errorKey,
                publicMessage: `The input type ${previousResult.type} is not supported by the filter parser.`,
            });
        }
    }
    if (!('all' in parserOptions) &&
        !parserOptions.token &&
        !parserOptions.group &&
        !parserOptions.collection) {
        toolbox.populateMessage({
            type: 'warning',
            content: "Couldn't find a pattern in all, token, group or collection, so nothing will be suffixed",
            errorKey: specifyErrors.PARSERS_ENGINE_INVALID_OPTION.errorKey,
        });
        return {
            type: 'SDTF Engine',
            engine: sdtfEngine,
        };
    }
    suffixByInner(sdtfEngine, parserOptions);
    return {
        type: 'SDTF Engine',
        engine: sdtfEngine,
    };
};
/* v8 ignore start */
export function suffixByInner(engine, options) {
    const query = getSdtfQuery(options.applyTo);
    (options.applyTo ? engine.query.run(query) : engine.query.getAllNodeStates()).forEach(node => {
        if ('all' in options) {
            node.rename(`${node.name}${options.all}`);
        }
        else if (node.isToken && options.token) {
            node.rename(`${node.name}${options.token}`);
        }
        else if (node.isGroup && options.group) {
            node.rename(`${node.name}${options.group}`);
        }
        else if (node.isCollection && options.collection) {
            node.rename(`${node.name}${options.collection}`);
        }
    });
}
/* v8 ignore stop */
//# sourceMappingURL=suffixBy.js.map