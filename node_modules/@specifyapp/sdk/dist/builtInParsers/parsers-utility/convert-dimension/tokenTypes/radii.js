import { UnresolvableModeLevelAlias, } from '@specifyapp/specify-design-token-format';
import { getDimensionUpdateValue, getDimensionUpdateValueOrUpdateAlias } from './dimension.js';
export function getRadiiUpdateValueOrUpdateAlias(radii, options, toolbox) {
    return radii
        .mapPrimitiveValue(v => (!!v ? getRadiiUpdateValue(v, options, toolbox) : undefined))
        .mapUnresolvableValueLevelAlias(_ => undefined)
        .mapResolvableValueLevelAlias(alias => {
        const { tokenState, targetMode, value } = alias.tokenState.resolveDeepStatefulValueForMode(alias.targetMode);
        if (value instanceof UnresolvableModeLevelAlias)
            throw new Error('Unreachable as token resolvability is checked before');
        const updateValue = getRadiiUpdateValue(value, options, toolbox);
        // @ts-expect-error: Array<radii> !== [radii, radii, radii, radii]
        tokenState.updateModeValue(targetMode, updateValue);
        return undefined;
    })
        .unwrap();
}
export function getRadiiUpdateValue(radii, options, toolbox) {
    return radii.map(innerValue => innerValue
        .mapPrimitiveValue(v => getDimensionUpdateValue(v, options, toolbox))
        .mapUnresolvableValueLevelAlias(_ => {
        throw new Error('Unreachable as token resolvability is checked before');
    })
        .mapResolvableValueLevelAlias(alias => {
        // We update the alias, and we return the format expected by the SDTF to update the token
        getDimensionUpdateValueOrUpdateAlias(innerValue, options, toolbox);
        return { $alias: alias.tokenState.path.toString(), $mode: alias.targetMode };
    })
        .unwrap());
}
//# sourceMappingURL=radii.js.map