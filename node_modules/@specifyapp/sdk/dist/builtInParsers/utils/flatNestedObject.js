import { SDTF_PATH_SEPARATOR } from '@specifyapp/specify-design-token-format';
import { isEmpty, merge } from 'lodash-es';
export function toNestedObject(flatObject) {
    return Object.entries(flatObject).reduce((acc, [path, token]) => {
        const nestedObject = path
            .split(SDTF_PATH_SEPARATOR)
            .reverse()
            .reduce((acc, key) => (isEmpty(acc) ? { [key]: token } : { [key]: acc }), {});
        return merge(acc, nestedObject);
    }, {});
}
export function makeDefaultPath(token) {
    return token.path
        .toArray()
        .slice(0, token.path.length - 1)
        .join(SDTF_PATH_SEPARATOR);
}
export function tokensToFlatObject(tokens, convertToken) {
    return tokens.reduce((acc, token) => {
        const convertedToken = convertToken(token);
        if (convertedToken === undefined || convertedToken === null)
            return acc;
        const defaultPath = makeDefaultPath(token);
        if (Array.isArray(convertedToken)) {
            for (let i = 0; i < convertedToken.length; i++) {
                const { value, path, name } = convertedToken[i];
                const resolvedPath = path ?? defaultPath;
                if (resolvedPath !== '') {
                    acc[resolvedPath] ??= {};
                    acc[path ?? defaultPath][name ?? token.name] = value;
                }
                else {
                    acc[name ?? token.name] = value;
                }
            }
        }
        else {
            const resolvedPath = convertedToken.path ?? defaultPath;
            if (resolvedPath !== '') {
                acc[convertedToken.path ?? defaultPath] ??= {};
                acc[convertedToken.path ?? defaultPath][convertedToken.name ?? token.name] = convertedToken.value;
            }
            else {
                acc[convertedToken.name ?? token.name] = convertedToken.value;
            }
        }
        return acc;
    }, {});
}
//# sourceMappingURL=flatNestedObject.js.map