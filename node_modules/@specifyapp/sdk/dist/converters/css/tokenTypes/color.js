import { matchIsRawColorHex, matchIsRawColorRgb, matchIsRawColorLab, matchIsRawColorLch, } from '@specifyapp/specify-design-token-format';
//@ts-ignore
import tinycolor from 'tinycolor2';
import { matchIsRawColorHsb, matchIsRawColorHsl } from '@specifyapp/specify-design-token-format';
import { unwrapInnerValue } from '../../_utils/unwrapInnerValue.js';
import { DEFAULT_UNRESOLVABLE_STRATEGY } from '../aliasStrategies/throwOnUnresolvable.js';
/**
 * Converts a `TokenState<'color'>` to a css value.
 * E.g: `#ff00ff`
 */
export function colorToCss(aliasStrategy, unresolvableAliasStrategy = DEFAULT_UNRESOLVABLE_STRATEGY) {
    return (tokenState) => tokenState
        .getStatefulValueResult()
        .mapResolvableTopLevelAlias(aliasStrategy)
        .mapUnresolvableTopLevelAlias(alias => unresolvableAliasStrategy(tokenState, alias))
        .mapTopLevelValue(value => value
        .mapRawValue(rawValue => rawColorToCss(rawValue, aliasStrategy, unresolvableAliasStrategy))
        .mapResolvableModeLevelAlias(aliasStrategy)
        .mapUnresolvableModeLevelAlias(alias => unresolvableAliasStrategy(tokenState, alias))
        .unwrap())
        .unwrap();
}
/**
 * Converts a `RawValueSignature<'color'>` to css.
 */
export function rawColorToCss(color, aliasStrategy, unresolvableAliasStrategy = DEFAULT_UNRESOLVABLE_STRATEGY) {
    const alpha = color.alpha.resolveDeepValue().unwrapValue();
    if (matchIsRawColorHex(color)) {
        // @ts-ignore - TS2590: Expression produces a union type that is too complex to represent
        return unwrapInnerValue(color.hex.mapPrimitiveValue(hex => renderHex(hex, alpha)), aliasStrategy);
    }
    else if (matchIsRawColorRgb(color)) {
        return `rgb${alpha < 1 ? 'a' : ''}(${unwrapInnerValue(color.red, aliasStrategy, unresolvableAliasStrategy)}, ${unwrapInnerValue(color.green, aliasStrategy, unresolvableAliasStrategy)}, ${unwrapInnerValue(color.blue, aliasStrategy, unresolvableAliasStrategy)}${alpha < 1 ? ', ' + alpha : ''})`;
    }
    else if (matchIsRawColorHsl(color)) {
        return `hsl(${unwrapInnerValue(color.hue, aliasStrategy, unresolvableAliasStrategy)}, ${unwrapInnerValue(color.saturation.mapPrimitiveValue(s => `${s}%`), aliasStrategy, unresolvableAliasStrategy)}, ${unwrapInnerValue(color.lightness.mapPrimitiveValue(l => `${l}%`), aliasStrategy, unresolvableAliasStrategy)}${alpha < 1 ? ' / ' + alpha : ''})`;
    }
    else if (matchIsRawColorHsb(color)) {
        return `hsv(${unwrapInnerValue(color.hue, aliasStrategy, unresolvableAliasStrategy)}, ${unwrapInnerValue(color.saturation.mapPrimitiveValue(s => `${s}%`), aliasStrategy, unresolvableAliasStrategy)}, ${unwrapInnerValue(color.brightness.mapPrimitiveValue(s => `${s}%`), aliasStrategy, unresolvableAliasStrategy)}${alpha < 1 ? ' / ' + alpha : ''})`;
    }
    else if (matchIsRawColorLab(color)) {
        return `lab(${unwrapInnerValue(color.lightness.mapPrimitiveValue(s => `${s}%`), aliasStrategy, unresolvableAliasStrategy)} ${unwrapInnerValue(color.aAxis, aliasStrategy, unresolvableAliasStrategy)} ${unwrapInnerValue(color.bAxis, aliasStrategy, unresolvableAliasStrategy)}${alpha < 1 ? ' / ' + alpha : ''})`;
    }
    else if (matchIsRawColorLch(color)) {
        return `lch(${unwrapInnerValue(color.lightness.mapPrimitiveValue(s => `${s}%`), aliasStrategy, unresolvableAliasStrategy)} ${unwrapInnerValue(color.chroma, aliasStrategy, unresolvableAliasStrategy)} ${unwrapInnerValue(color.hue, aliasStrategy, unresolvableAliasStrategy)}${alpha < 1 ? ' / ' + alpha : ''})`;
    }
    else {
        throw new Error('Unreachable');
    }
}
/**
 * Converts a color to css.
 */
export function colorValueToCss(color) {
    const alpha = color.alpha;
    switch (color.model) {
        case 'hex': {
            return renderHex(color.hex, alpha);
        }
        case 'rgb': {
            const tc = tinycolor({
                r: color.red,
                g: color.green,
                b: color.blue,
            });
            tc.setAlpha(alpha);
            return tc.toRgbString();
        }
        case 'hsl': {
            const tc = tinycolor({
                h: color.hue,
                s: color.saturation,
                l: color.lightness,
            });
            tc.setAlpha(alpha);
            return tc.toHslString();
        }
        case 'hsb': {
            const tc = tinycolor({
                h: color.hue,
                s: color.saturation,
                v: color.brightness,
            });
            tc.setAlpha(alpha);
            return tc.toHsvString();
        }
        case 'lch': {
            return `lch(${color.lightness}% ${color.chroma} ${color.hue}${alpha < 1 ? ' / ' + alpha : ''})`;
        }
        case 'lab': {
            return `lab(${color.lightness}% ${color.aAxis} ${color.bAxis}${alpha < 1 ? ' / ' + alpha : ''})`;
        }
    }
}
function renderHex(hex, alpha) {
    const tc = tinycolor(hex);
    if (alpha === 1) {
        return tc.toHexString();
    }
    tc.setAlpha(alpha);
    return tc.toHex8String();
}
//# sourceMappingURL=color.js.map