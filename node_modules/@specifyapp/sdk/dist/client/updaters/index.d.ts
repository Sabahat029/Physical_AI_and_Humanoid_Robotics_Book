import { SDTFQuery } from '@specifyapp/specify-design-token-format';
import { OptionsWithoutApplyToAndRemoteExecution, UpdaterFunction } from './definitions.js';
import { ChangeCaseParserOptions } from '../../builtInParsers/parsers-utility/change-case/definition.js';
import { ConvertColorParserOptions } from '../../builtInParsers/parsers-utility/convert-color/definition.js';
import { ConvertDimensionParserOptions } from '../../builtInParsers/parsers-utility/convert-dimension/definition.js';
import { MakeLineHeightRelativeParserOptions } from '../../builtInParsers/parsers-utility/make-line-height-relative/definition.js';
import { PrefixByParserOptions } from '../../builtInParsers/parsers-utility/prefix-by/definition.js';
import { ReplaceStringParserOptions } from '../../builtInParsers/parsers-utility/replace-string/definition.js';
import { RoundNumberParserOptions } from '../../builtInParsers/parsers-utility/round-number/definition.js';
/**
 * Update all the tokens that contains a color to the given format for a given query. If the query isn't provided, then all the tokens will be updated.
 * It means that tokens such as: color, shadow, gradient, etc... Will be affected.
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(color({ toFormat: 'hex' }, { where: { token: '.*Color', select: true } }))
 * sdtf.withQuery({ where: { token: '.*Color', select: true } }).update(color({ toFormat: 'hex' }))
 */
declare function color(options: OptionsWithoutApplyToAndRemoteExecution<ConvertColorParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Update all the tokens that contains a dimension to the given unit for a given query. If the query isn't provided, then all the tokens will be updated.
 * It means that tokens such as: dimension, spacing, textStyle, radii, etc... Will be affected.
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(dimension({ toFormat: 'hex', baseValue: { rem: 12 } }, { where: { token: '.*Shadow', select: true } }))
 * sdtf.withQuery({ where: { token: '.*Shadow', select: true } }).update(dimension({ toFormat: 'rem', baseValue: { rem: 16 } }))
 */
declare function dimension(options: OptionsWithoutApplyToAndRemoteExecution<ConvertDimensionParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Update all the tokens name to the given casing for a given query. If the query isn't provided, then all the tokens will be updated.
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(changeCase({ toFormat: 'camelCase' }))
 * sdtf.withQuery({ where: { token: 'snake_.*_case', select: true } }).update(changeCase({ toFormat: 'kebabCase' }))
 */
declare function changeCase(options: OptionsWithoutApplyToAndRemoteExecution<ChangeCaseParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Replacing names with a given `regex` and a given `replaceBy`. You can either replace for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(replaceString({ all: {regex: 'hello', replaceBy: 'world' } }))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(replaceString({ all: {regex: 'hello', replaceBy: 'world' } }))
 */
declare function replaceString(options: OptionsWithoutApplyToAndRemoteExecution<ReplaceStringParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Prefixing names with a given prefix. You can either replace for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(prefixBy({ all: 'prefix-' }))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(prefixBy({ all: 'prefix-' }))
 */
declare function prefixBy(options: OptionsWithoutApplyToAndRemoteExecution<PrefixByParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Suffixing names with a given suffix. You can either replace for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(suffixBy({ all: '-suffix' }))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(suffixBy({ all: '-suffix' }))
 */
declare function suffixBy(options: OptionsWithoutApplyToAndRemoteExecution<PrefixByParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Convert your lineHeight from absolut to relative value. You can either convert for all or pick what you want
 * This methods should be used with the `SDTFClient.update` or `SDTFClient.withQuery` methods.
 * @example
 * sdtf.update(makeLineHeightRelative({}))
 * sdtf.withQuery({ where: { token: 'myToken.*', select: true } }).update(makeLineHeightRelative({ basePixelValue: 24 }))
 */
declare function makeLineHeightRelative(options: OptionsWithoutApplyToAndRemoteExecution<MakeLineHeightRelativeParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
/**
 * Round numbers to a given precision. You can either round for all or pick what you want.
 * This methods should be used with the `SDTFClient.update` method.
 * @example
 * sdtf.update(roundNumber({ precision: 2 }))
 * @param options
 * @param applyTo
 */
declare function roundNumber(options: OptionsWithoutApplyToAndRemoteExecution<RoundNumberParserOptions>, applyTo?: SDTFQuery): UpdaterFunction;
export declare const updaters: {
    dimension: typeof dimension;
    color: typeof color;
    changeCase: typeof changeCase;
    replaceString: typeof replaceString;
    prefixBy: typeof prefixBy;
    suffixBy: typeof suffixBy;
    makeLineHeightRelative: typeof makeLineHeightRelative;
    roundNumber: typeof roundNumber;
};
export {};
//# sourceMappingURL=index.d.ts.map